<h1>Results</h1>


Running the program takes a good while if one doesn't change the flags
in the Makefile: in debug mode (the default) and on only a single
machine, it takes about 3h45min on my Athlon XP 2GHz. Fortunately, but
setting <code>debug-mode = off</code> in the Makefile, this can be
reduced significantly, to about 23 minutes, a much more reasonable time.




If run, the program prints the following output, explaining what it is
doing during all that time:
@code
examples/step-18> time make run
============================ Running step-18
Timestep 1 at time 1
  Cycle 0:
    Number of active cells:       3712 (by partition: 3712)
    Number of degrees of freedom: 17226 (by partition: 17226)
    Assembling system... norm of rhs is 2.34224e+10
    Solver converged in 117 iterations.
    Updating quadrature point data...
  Cycle 1:
    Number of active cells:       12812 (by partition: 12812)
    Number of degrees of freedom: 51726 (by partition: 51726)
    Assembling system... norm of rhs is 2.34227e+10
    Solver converged in 130 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 2 at time 2
    Assembling system... norm of rhs is 2.30852e+10
    Solver converged in 131 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 3 at time 3
    Assembling system... norm of rhs is 2.27792e+10
    Solver converged in 126 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 4 at time 4
    Assembling system... norm of rhs is 2.25107e+10
    Solver converged in 124 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 5 at time 5
    Assembling system... norm of rhs is 2.22883e+10
    Solver converged in 122 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 6 at time 6
    Assembling system... norm of rhs is 2.21272e+10
    Solver converged in 118 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 7 at time 7
    Assembling system... norm of rhs is 2.20652e+10
    Solver converged in 117 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 8 at time 8
    Assembling system... norm of rhs is 2.22501e+10
    Solver converged in 127 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 9 at time 9
    Assembling system... norm of rhs is 2.32742e+10
    Solver converged in 144 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 10 at time 10
    Assembling system... norm of rhs is 2.55929e+10
    Solver converged in 149 iterations.
    Updating quadrature point data...
    Moving mesh...
@endcode
In other words, it is computing on 12,000 cells and with some 52,000
unknowns. Not a whole lot, but enough for a coupled three-dimensional
problem to keep a computer busy for a while. At the end of the day,
this is what we have for output:
@code
examples/step-18> ls -l *.d2
-rw-r--r--  1 bangerth wheeler 8797414 May 25 09:10 solution-0001.0000.d2
-rw-r--r--  1 bangerth wheeler 8788500 May 25 09:32 solution-0002.0000.d2
-rw-r--r--  1 bangerth wheeler 8763718 May 25 09:55 solution-0003.0000.d2
-rw-r--r--  1 bangerth wheeler 8738940 May 25 10:17 solution-0004.0000.d2
-rw-r--r--  1 bangerth wheeler 8710104 May 25 10:39 solution-0005.0000.d2
-rw-r--r--  1 bangerth wheeler 8685388 May 25 11:01 solution-0006.0000.d2
-rw-r--r--  1 bangerth wheeler 8649088 May 25 11:23 solution-0007.0000.d2
-rw-r--r--  1 bangerth wheeler 8585146 May 25 11:45 solution-0008.0000.d2
-rw-r--r--  1 bangerth wheeler 8489764 May 25 12:07 solution-0009.0000.d2
-rw-r--r--  1 bangerth wheeler 8405388 May 25 12:29 solution-0010.0000.d2
@endcode


Let us convert these files in deal.II intermediate format to gmv
format (this assumes that you have already compiled the 
step-19 example program):
@code
examples/step-18> ../step-19/step-19

Converter from deal.II intermediate format to other graphics formats.

Usage: ./step-19 [-p parameter_file] list_of_input_files [-x output_format] output_file

examples/step-18> ../step-19/step-19 solution-0001.0000.d2 -x gmv solution-0001.0000.gmv
examples/step-18> ../step-19/step-19 solution-0002.0000.d2 -x gmv solution-0002.0000.gmv
[...]
@endcode
Of course, since we have run the program only in sequential mode, we
do have only one intermediate file for each time step that we have to
take as input.



If we visualize these files with GMV, we get to see the full picture
of the disaster our forced compression wreaks on the cylinder (colors in the
images encode the norm of the stress in the material):


<table width="100%">
  <tr width="100%">
    <td width="33%">
      @image html step-18.sequential-0002.0000.png
       Time = 2
    </td>

    <td width="33%">
      @image html step-18.sequential-0005.0000.png
       Time = 5
    </td>

    <td width="33%">
      @image html step-18.sequential-0007.0000.png
       Time = 7
    </td>
  </tr>

  <tr width="100%">
    <td width="33%">
      @image html step-18.sequential-0008.0000.png
      Time = 8
    </td>

    <td width="33%">
      @image html step-18.sequential-0009.0000.png
      Time = 9
    </td>

    <td width="33%">
      @image html step-18.sequential-0010.0000.png
      Time = 10
    </td>
  </tr>
</table>


As is clearly visible, as we keep compressing the cylinder, it starts
to buckle and ultimately collapses. Towards the end of the simulation,
the deflection pattern becomes nonsymmetric (the cylinder top slides
to the right). The model clearly does not provide for this (all our
forces and boundary deflections are symmetric) but the effect is
probably physically correct anyway: in reality, small inhomogeneities
in the body's material properties would lead it to buckle to one side
to evade the forcing; in numerical simulations, small perturbations
such as numerical round-off or an inexact solution of a linear system
by an iterative solver could have the same effect. Another typical source for
asymmetries in adaptive computations is that only a certain fraction of cells
is refined in each step, which may lead to asymmetric meshes even if the
original coarse mesh was symmetric.




Whether the computation is fully converged is a different matter. In order to
see whether it is, we ran the program again with one more global refinement at
the beginning and with the time step halved. This would have taken a very long
time on a single machine, so we used our cluster again and ran it on 16
processors (8 dual-processor machines) in parallel. The beginning of the output
now looks like this:
@code
Timestep 1 at time 0.5
  Cycle 0:
    Number of active cells:       29696 (by partition: 1862+1890+1866+1850+1864+1850+1858+1842+1911+1851+1911+1804+1854+1816+1839+1828)
    Number of degrees of freedom: 113100 (by partition: 7089+7218+6978+6972+7110+6840+7119+7023+7542+7203+7068+6741+6921+6759+7464+7053)
    Assembling system... norm of rhs is 1.05874e+10
    Solver converged in 289 iterations.
    Updating quadrature point data...
  Cycle 1:
    Number of active cells:       102097 (by partition: 6346+6478+6442+6570+6370+6483+6413+6376+6403+6195+6195+6195+6494+6571+6371+6195)
    Number of degrees of freedom: 358875 (by partition: 22257+22161+22554+22482+21759+23361+23040+21609+22347+20937+21801+21678+24126+25149+21321+22293)
    Assembling system... norm of rhs is 3.46364e+10
    Solver converged in 249 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 2 at time 1
    Assembling system... norm of rhs is 3.42269e+10
    Solver converged in 248 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 3 at time 1.5
    Assembling system... norm of rhs is 3.38229e+10
    Solver converged in 247 iterations.
    Updating quadrature point data...
    Moving mesh...

Timestep 4 at time 2
    Assembling system... norm of rhs is 3.34247e+10
    Solver converged in 247 iterations.
    Updating quadrature point data...
    Moving mesh...

[...]

Timestep 20 at time 10
    Assembling system... norm of rhs is 3.2449e+10
    Solver converged in 493 iterations.
    Updating quadrature point data...
    Moving mesh...
@endcode
That's quite a good number of unknowns, given that we are in 3d. The output of
this program are 16 files for each time step:
@code
examples/step-18> ls -l solution-0001.000*
-rw-r--r--    1 bangerth mfw       4325219 Aug 11 09:44 solution-0001.0000-000.d2
-rw-r--r--    1 bangerth mfw       4454460 Aug 11 09:44 solution-0001.0000-001.d2
-rw-r--r--    1 bangerth mfw       4485242 Aug 11 09:43 solution-0001.0000-002.d2
-rw-r--r--    1 bangerth mfw       4517364 Aug 11 09:43 solution-0001.0000-003.d2
-rw-r--r--    1 bangerth mfw       4462829 Aug 11 09:43 solution-0001.0000-004.d2
-rw-r--r--    1 bangerth mfw       4482487 Aug 11 09:43 solution-0001.0000-005.d2
-rw-r--r--    1 bangerth mfw       4548619 Aug 11 09:43 solution-0001.0000-006.d2
-rw-r--r--    1 bangerth mfw       4522421 Aug 11 09:43 solution-0001.0000-007.d2
-rw-r--r--    1 bangerth mfw       4337529 Aug 11 09:43 solution-0001.0000-008.d2
-rw-r--r--    1 bangerth mfw       4163047 Aug 11 09:43 solution-0001.0000-009.d2
-rw-r--r--    1 bangerth mfw       4288247 Aug 11 09:43 solution-0001.0000-010.d2
-rw-r--r--    1 bangerth mfw       4350410 Aug 11 09:43 solution-0001.0000-011.d2
-rw-r--r--    1 bangerth mfw       4458427 Aug 11 09:43 solution-0001.0000-012.d2
-rw-r--r--    1 bangerth mfw       4466037 Aug 11 09:43 solution-0001.0000-013.d2
-rw-r--r--    1 bangerth mfw       4505679 Aug 11 09:44 solution-0001.0000-014.d2
-rw-r--r--    1 bangerth mfw       4340488 Aug 11 09:44 solution-0001.0000-015.d2
@endcode
We merge and convert these 16 intermediate files into a single gmv file as
follows: 
@code
examples/step-18> time ../step-19/step-19 solution-0001.0000-* -x gmv -o solution-0001.0000.gmv

real    0m45.929s
user    0m41.290s
sys     0m0.990s
examples/step-18> ls -l solution-0001.0000.gmv
-rw-r--r--    1 bangerth mfw      68925360 Aug 11 17:04 solution-0001.0000.gmv
@endcode

Doing so for all time steps, we obtain gmv files that we can visualize (albeit
with some difficulty, due to their size gmv isn't exactly fast when plotting
them). Here are first the mesh on which we compute as well as the partitioning
for the 16 processors:


<table width="100%">
  <tr width="100%">
    <td width="49%">
      @image html step-18.parallel-000mesh.png
    </td>

    <td width="49%">
      @image html step-18.parallel-0002.p.png
    </td>
  </tr>
</table>


Finally, here is the same output as we have shown before for the much smaller
sequential case:


<table width="100%">
  <tr width="100%">
    <td width="33%">
      @image html step-18.parallel-0002.s.png
       Time = 2
    </td>

    <td width="33%">
      @image html step-18.parallel-0005.s.png
       Time = 5
    </td>

    <td width="33%">
      @image html step-18.parallel-0007.s.png
       Time = 7
    </td>
  </tr>

  <tr width="100%">
    <td width="33%">
      @image html step-18.parallel-0008.s.png
       Time = 8
    </td>

    <td width="33%">
      @image html step-18.parallel-0009.s.png
       Time = 9
    </td>

    <td width="33%">
      @image html step-18.parallel-0010.s.png
       Time = 10
    </td>
  </tr>
</table>


If one compares this with the previous run, the results are qualitatively
similar, but quantitatively definitely different. The previous computation was
therefore certainly not converged, though we can't say for sure anything about
the present one. One would need an even finer computation to find out. However,
the point may be moot: looking at the last picture in detail, it is pretty
obvious that not only is the linear small
deformation model we chose completely inadequate, but for a realistic
simulation we would also need to make sure that the body does not intersect
itself during deformation. Without such a formulation we cannot expect anything
to make physical sense, even if it produces nice pictures!

