#!/usr/local/bin/perl

# Documentation generator. 
# Torben Weis (weis@kde.org) and Sirtaj Kang (taj@kde.org)
# $Id$

#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

###########################################################
#
# Global Variables
#
###########################################################

# system options
require 5.000;

$PREFIX="/usr/local";
push( @INC, $PREFIX."/share/kdoc");

require Ast;

# User options

$dontDoPrivate	= 1;
$strictParser	= 0;
$documentAll	= 1;
$docDeprecated	= 1;
$docInternal	= 1;
$debug		= 0;
$docPath	= ".";
$urlBase	= "";
$libPath	= ".";
$lib		= "";
$genHTML	= 0;
$genTeX		= 0;
$genMan		= 0;
$quiet		= 0;

# running environment
($version = '$Version$') =~ s/:\s*//g;

$version =~ s/Version//g;

$thisHost	= `uname -n`;	chop $thisHost;
$user		= `whoami`;	chop $user;

$generatedByText= 'Documentation generated by '.$user. '@'.
		$thisHost.' on '.`date`;

$libPath	= $ENV{'KDOCLIBS'} if $ENV{'KDOCLIBS'} ne "";

# globals - for method

$exceptions	= "";
%paramDesc	= ();
$paramName	= "";
$paramText	= "";
$retText	= "";
$see		= "";
$text		= "";
$methInternal	= 0;
$methDeprecated = 0;

# for class 
$class			= "";
$classAuthor		= "";
$classDeprecated	= 0;
$classInternal		= 0;
$classSee		= "";
$classShortText		= "";
$classShortTextSet	= 0;
$classText		= "";
$classVersion		= "";
$classInherits		= "";
$classAbstract		= 0;
$classTmplArgs		= "";

%classRef		= (); # KDOC reference file
%classSource		= (); # tracks headers given a class name
%classNode		= (); # tracks nodes given a class name
@headerList		= (); # list of processed header files

$filename		= ""; # Current file being processed

# index of stuff that shouldn't flag referencing errors
# (not currently used)

%noErr = ();
$noErr{ "void" } = 1;
$noErr{ "int" } = 1;
$noErr{ "uint" } = 1;
$noErr{ "uchar" } = 1;
$noErr{ "short" } = 1;
$noErr{ "ushort" } = 1;
$noErr{ "unsignedint" } = 1;
$noErr{ "unsignedchar" } = 1;
$noErr{ "unsignedshort" } = 1;
$noErr{ "float" } = 1;
$noErr{ "double" } = 1;
$noErr{ "short" } = 1;
$noErr{ "char" } = 1;
$noErr{ "unsigned" } = 1;
$noErr{ "bool" } = 1;
$noErr{ "long" } = 1;
$noErr{ "string" } = 1;

# for main

$i = 0;
@myargs = @ARGV;

%children = ();
%parents = ();

# "<>" is the root of all classes.
$children{"<>"} = "";
$parents{"<>"} = "<>";

$rootNode = Ast::New("ROOT");

####
#
# Function addClass
# 	Inserts a class into the hierarchy
####

sub addClass
{
	my($parent, $child) = @_;

	$parents{ $child } = $parent;

	$children{ $parent } = $child.";".$children{ $parent };

	$children{ $child } = "" if !defined $children{ $child };
}

###########################################################
#
# Function
#  readLibrary
#
###########################################################

sub readLibrary
{
    my( $libname ) = @_;
    my( $prefix );
    my( $libFull );

    $libFull = $libPath."/".$libname.".kdoc";

    open( IMP, "$libFull" ) 
    	|| die "Could not open ".$libFull." for reading\n";

    # the first line of a library contains the base url under
    # which is was stored (using the -u flag at invokation of
    # kdoc)
    $prefix = <IMP>;
    chop $prefix;

    # However, there is one problem: kdoc references other symbols
    # relative to the files of the library it is working on and that
    # will not be in the present directory but somewhere else.
    # Therefore $prefix is relative to the present directory, while
    # the files of the present library will go to $docPath; we
    # therefore need to modify $prefix for the number of subdirectories
    # in $docPath. That scheme will fail, however, if $docPath is an
    # absolute path, if $prefix is an absolute path or if $docPath
    # contains "../". I (WB) am not proficient enough to invent a
    # workaround

    foreach ( split "/", $prefix)
    {
	$prefix = "../" . $prefix;
    }
    if ( ! ( $prefix =~ /\/$/) )
    {
	$prefix .= "/";
    }

    while ( <IMP> )
    {
	chop;
	if ( /^(.*)=(.*)$/ )
	{
	    $classRef{ $1 } = $prefix . "$2";
	}
	if( /^(\w+)=/ ) {
		# add classes to external list
		$classSource{ $1 } = $libname;
	}
    }

    close( IMP );
}

###########################################################
#
# Function
#  processClass
#
###########################################################

sub processClass
{
    my( $end );

# New Ast Node for class

    $classNode = Ast::New( $class );

# use first line of text as short text if we have none yet.
    if( $classShortText eq "" && $classText ne "" ) {
	    $_ = $classText;
	    /((\s|\w|[^.\n])*)\.*/;
	    $classShortText = $1." ";
	    $classShortTextSet = 1;
    }



# work out ancestors
    $_ = $classInherits;
    tr/\:\{//d;
    s/protected//g;
    s/private//g;
    s/public//g;
    s/virtual//g;

    if ( !( /^\s*$/ ) )
    {
	    foreach $c ( split /,/, $_ )
	    {
		    $c =~ s/\s//g;
			    addClass( $c, $class );

		    $inheritNode = Ast::New($c);
		    $classNode->AddPropList( "Ancestors", $inheritNode );
	    }

    }
    else {
	    addClass( "<>", $class );	
    }

# process the rest of the class declaration

    while ( <IN> )
    {
	next if	/^\s*$/g;
	
# parse out // comments, except where in a string or 
	s#//.*$##g unless m#"[^"]+".*//# || m#^\s*///#;


	# if we find a "template <whatever>" on a single line,
        # concatenate it with the next line
        if ( /^\s*(template\s*<(([-\w,_\s]|<([-\w,+\s])+>)+)>\s*)\n/ ) {
	    $_ = $1 . " " . <IN>;
	}

	$line = $_;

	if ( /^\s*\}\s*;\s*(\/\/.*)?$/ )
	{
# end of class declaration
# dump all stored stuff to file

		print "CLASS END: $class\n" if $debug;

		if( ($classInternal == 0 || $docInternal )
				&& ( $classDeprecated == 0 || $docDeprecated ) ) {

			# add class to list only if it is expected to be
			# documented

			addReference( $classNode->{"astNodeName"}, 
				$classNode->{"astNodeName"}.".html" );

			print "Added $class to tree\n" if $debug;

			$rootNode->AddPropList( "classes", $classNode );

			$filename =~ s/^\s+$//g;
			$classAuthor =~ s/^\s+$//g;
			$classVersion =~ s/^\s+$//g;
			$classText =~ s/^\s+$//g;
			$classSee =~ s/^\s+$//g;

			$classNode->AddProp( "Author",		$classAuthor );
			$classNode->AddProp( "ClassSee",	$classSee );
			$classNode->AddProp( "ClassShort",	$classShortText );
			$classNode->AddProp( "Deprecated",	$classDeprecated );
			$classNode->AddProp( "Description",	$classText );
			$classNode->AddProp( "Header",		$filename );
			$classNode->AddProp( "Internal",	$classInternal );
			$classNode->AddProp( "TmplArgs",	$classTmplArgs );
			$classNode->AddProp( "Version",		$classVersion );

		}

		resetClassDoc();

		return;
	}
	elsif ( /^\s*public\s*:\s*$/ && $access ne "public" )
	{
		$access = "public";
	}
	elsif ( /^\s*protected\s*:\s*$/ && $access ne "protected" )
	{
		$access = "protected";
	}
	elsif ( /^\s*private\s*:\s*$/ && $access ne "private" )
	{
		$access = "private";
	}
	elsif ( /^\s*signals\s*:\s*$/ && $access ne "signals" )
	{
		$access = "signals";
	}
	elsif ( /^\s*protected\s+slots\s*:\s*$/ && $access ne "protected_slots" )
	{
		$access = "protected_slots";
	}
	elsif ( /^\s*public\s+slots\s*:\s*$/ && $access ne "public_slots" )
	{
		$access = "public_slots";
	}
	elsif ( /^\s*private\s+slots\s*:\s*$/ && $access ne "private_slots" )
	{
		$access = "private_slots";
	}

	#### Preprocessor directive

	elsif( /^\s*#[\w\.-_]+/ ) {

		print "CPP: $_\n" if $debug;

		# skip lines carried on with \
		while( /\\\s*$/ ) {
			if( !($_ = <IN>) ) {
				die "Bad Finish";
			}
			print "CPP: Skipped: $_" if $debug;
		}
	}

	#### Typedef

	elsif( /^\s*typedef\s+(.*[&\*\s])\s*([\w-:_]+)\s*(\[[^\]]*\])*;\s*$/ ) {
	    #                  1        2           3             4
	    # 1: type name, possibly more than one
	    # 2: name of new type
	    # 3: possible array declaration(s)
	    # 4: anything else
		print "TYPED: $2: $1\n" if $debug;

		if( ( $methInternal == 0 || $docInternal)
			&& ($methDeprecated == 0  || $docDeprecated) ) {

			addReference( $class."::".$2, $class.".html#".$2 );

			$newNode = Ast::New( $2 );

			$classNode->AddPropList( $access, $newNode );

			$newNode->AddProp( "Keyword", "typedef" );
			$newNode->AddProp( "Description", $text );
			$newNode->AddProp( "See", $see );
			$newNode->AddProp( "MethInternal", $methInternal );
			$newNode->AddProp( "MethDeprecated", $methDeprecated );

			$newNode->AddProp( "Type", $1 );
			$newNode->AddProp( "Array", $3 );
		}

		resetMemberDoc();
	}

	#### Enum

	elsif ( /^\s*enum\s+([\w_]*)\s*\{(.*)(\/\/.*)?/ )
	{
		$enum = $1;
		$tmp = $2;
		$args = "";

		# collect constants till } is found

		while ( !($tmp =~ /\}/) )
		{
			$args = $args . $tmp;
			$tmp = <IN>;
		}

		$_ = $tmp;
		/^(.*)\}/;
		$args = $args . $1;


		# update Ast node

		if( ( !$methInternal || $docInternal)
			&& (!$methDeprecated || $docDeprecated) ) {

			addReference( $class."::".$enum, $class.".html#".$enum );

			$see =~ s/^\s*$//g;
			$text =~ s/^\s*$//g;
			$args =~ s/^\s*$//g;

			$newNode = Ast::New( $enum );
			$classNode->AddPropList( $access, $newNode );
			$newNode->AddProp( "Keyword", "enum" );
			$newNode->AddProp( "Description", $text );
			$newNode->AddProp( "See", $see );
			$newNode->AddProp( "Constants", $args );
			$newNode->AddProp( "MethInternal", $methInternal );
			$newNode->AddProp( "MethDeprecated", $methDeprecated );
		}

		resetMemberDoc();
	}

	#### parse out Q_OBJECT macro
	elsif ( /^\s*Q_OBJECT[^\w]+(\/\/.*)?/ ) {
		# dont do anything
	}


	#### Variables
	elsif ( /^[^\(]*$/ && /^(?:[\w_\:\s]+(?:<(?:(?:[-\w,_\s]|<(?:[-\w,+\s])+>)+)>)?(?:::)?)[\&\s*]+[\w_]+\s*(\[[^\]]*\])*\s*;\s*(\/\/.*)?$/ )
	    #       1               2                                                            3      4           5                 6
	    # 1: variable declarations have no ()
	    # 2: data type, possibly several words as in 'unsigned int'
	    # 3: reference pointer or at least a space before variable name
	    # 4: variable name
	    # 5: array declaration
	    # 6: spaces and or comments
	{
	    $str = $_;
	    
	    # split variable declaration:
	    # $1 = data type
	    # $2 = reference or pointer (why are there two \s's?)
	    # $3 = variable name
	    # $4 = array declaration
	    $str =~ /^(.+)([\s&\s\*])([\w_]+)\s*((\[[^\]]*\])*)\s*;\s*$/;
	    $var               = $3;
	    $rest              = $1.$2;
	    $array_declaration = $4;

	
	    if( ( !$methInternal || $docInternal)
			    && (!$methDeprecated || $docDeprecated) ) {

		    addReference( $class."::".$var, $class.".html#".$var );

		    $rest =~ s/^\s*$//g;
		    $see =~ s/^\s*$//g;
		    $text =~ s/^\s*$//g;

		    $newNode = Ast::New( $var );
		    $classNode->AddPropList( $access, $newNode );
		    $newNode->AddProp( "Keyword", "property" );
		    $newNode->AddProp( "Type", $rest );
		    $newNode->AddProp( "Array", $array_declaration);
		    $newNode->AddProp( "Description", $text );
		    $newNode->AddProp( "See", $see );
		    $newNode->AddProp( "MethInternal", $methInternal );
		    $newNode->AddProp( "MethDeprecated", $methDeprecated );
	    }

	    resetMemberDoc();
	}


	#### Nested class
	
	elsif ( /^\s*(class|struct)/ ) {
		# TODO: Implement nested classes
		# Till then, find end of declaration
		print "NESTED $_\n" if $debug;

		if( !/;/ )
		{
# probably unterminated as yet
			print "\nNESTED begin (for $methodName): $_\n" 
				if $debug == 1;
			$foundMemberEnd = 0;
			$lookingFor = ";";
			$depth = 0;

			while( $foundMemberEnd == 0 ) {

				if( /\{/ ) {
					$depth += countReg( $_, "\{" );
					$lookingFor = "\}";
				}

				print "NESTED '$lookingFor': $_\n" if $debug == 1;

				if ( /$lookingFor/ ) 
				{
					$depth -= countReg( $_, $lookingFor );

					$foundMemberEnd = 1 if $depth <= 0;
				}

				if ($foundMemberEnd == 0 ) {
					$_ = <IN>;
					s#//.*$##g;
				}
			}
		}
	}
	elsif ( m#^\s*///\s*(.*)#  && $strictParser == 0 ) {
		# DOC++ style "///" single-line member doccer
		# will be used only if no other documentation exists.

		resetMemberDoc();

		$text = $1;

		print "DOCXX-STYLE: $text\n" if $debug != 0;
	}

	elsif ( /^\s*\/\// )
	{
		# parse out comment
		print "C++ comment: $_" if $debug != 0;
	}

	elsif ( /^\s*\/\*\*+\s*(.*)\*+\/\s*/ && $strictParser == 0 ) {
		# single-line "/**..*/" type doc line
		# not allowed by the spec but we'll let it pass 
		# if we're being lenient.

		resetMemberDoc();

		$text		= $1;
		print "ONELINE: $text\n" if $debug == 1;
	}

	elsif( /^\s*\/\*[^*]/ ) {
		# (multiline) comment
		while( !/\*\// ) {
			# skip lines till we find its end
			$_ = <IN>;
		}
	}

	elsif ( /^\s*\/\*\*+\s*(.*)/ ) {
	# member documentation begins
		processMemberDoc();
	}

	#### Member Function

	elsif ( /^\s*([^\(]*)\s+([^\s\(]+)\s*\((.*)(\/\/.*)?$/ ) 
	{
	    # note that the return type may contain
	    # template <whatever>!
		processMethod( $1, $2, $3 );
	}

    }

} # processClass
 
sub processMethod {

	my( $returnType, $methodName, $rest ) = @_;




# ensure that everything after the operator keyword goes into the
# member name and not the return type

	if( $returnType =~ /operator/ ) {
		$returnType =~ s/(operator.*)//g;
		$methodName = $1." ".$methodName;
	}

# special case: if we have operator(), then the operator keyword got
# matched into methodName, the first "(" was thrown away and $rest
# contains ") (argumentlist)..."
        if( ($methodName =~ /^operator$/) && ($rest =~ /^\)/) ) {
	    $methodName .= " ()";
	    $rest =~ s/^\)\s*\(//;
	}

# ensure that "*" is part of return type

	if( $methodName =~ /^\s*([\*|\&]+)(.*)$/ ) {
		$returnType = $returnType.$1;
		$methodName = $2;
	}

## Read the parameters ($3 onward)

	$params = "";

	# Find end of params
	while ( !($rest =~ /^[^)]*\)(.*)(\/\/.*)?$/) )
	{
		print "SEARCHING: $rest\n" if $debug == 1;
		$params = $params . $rest;
		($rest = <IN>) =~ s#//.*$##g;
	}

	$rest =~ s#//.*$##g;
	$_ = $rest;
	/^([^\)]*)\)(.*)/;

	# include all parameters before )
	$params .= $1;
	my($restOfLine) = $2;

	my($constness) = "";

	if( $restOfLine =~ /^\s*const/ ) {
		$constness = "const";
	}

# need to skip inline function if it is there, or if the
# end of declaration is staggered for some other reason.

	if( ! /\)[\s\w=]*;/ )
	{
# probably unterminated as yet
		print "\nINLINE begin (for $methodName): $_\n" if $debug == 1;

		$_ = $rest;
		$foundMemberEnd = 0;
		$lookingFor = ";";
		$depth = 0;

		while( $foundMemberEnd == 0 ) {

			if( /\{/ ) {
				$depth += countReg( $_, "\{" );
				$lookingFor = "\}";
			}

			print "INLINE '$lookingFor': $_\n" if $debug == 1;

			if ( /$lookingFor/ ) 
			{
				$depth -= countReg( $_, $lookingFor );

				$foundMemberEnd = 1 if $depth <= 0;
			}

			if ($foundMemberEnd == 0 ) {
				$_ = <IN>;
				s#//.*$##g;
			}
		}
	}

	# Register if not internal or deprecated

	if( ( !$methInternal || $docInternal)
			&& (!$methDeprecated || $docDeprecated) ) {

		$returnType	=~ s/^\s*$//g;
		$see		=~ s/^\s*$//g;
		$text		=~ s/^\s*$//g;
		$retText	=~ s/^\s*$//g;
		$params		=~ s/^\s*$//g;
		$constness	=~ s/^\s*$//g;

		addReference( $class."::".$methodName, $class.".html#".$methodName );

		$newNode = Ast::New( $methodName );
		$classNode->AddPropList( $access, $newNode );

		$newNode->AddProp( "ReturnType", $returnType );
		$newNode->AddProp( "Const", $constness );
		$newNode->AddProp( "Parameters", $params );
		$newNode->AddProp( "Keyword", "method" );
		$newNode->AddProp( "Description", $text );
		$newNode->AddProp( "Returns", $retText );
		$newNode->AddProp( "See", $see );
		$newNode->AddProp( "Exceptions", $exceptions );
		$newNode->AddProp( "MethInternal", $methInternal );
		$newNode->AddProp( "MethDeprecated", $methDeprecated );

		foreach $param ( keys %paramDesc ) {
			$paramNode = Ast::New( $param );
			($desc = $paramDesc{$param}) =~ s/^\s*$//g;
				$paramNode->AddProp("Description", $desc );

			$newNode->AddPropList( "ParamDoc", $paramNode );
		}
	}

	resetMemberDoc();
} # processMethod

#
# Processes a doc comment
# 

sub processMemberDoc
{
	my( $endDocBlock )	= 0;
	my( $paramFlag )	= 0;
	my( $retFlag ) 		= 0;

	resetMemberDoc();

	$lastLineBlank = 0;

# allow documentation on first line only if
# we're being lenient.

	if( $strictParser == 0 ) {
		$text = $1;
	}
	else {
		$text = "";
	}

	$endDocBlock = 0;

	while ( $endDocBlock == 0 ) {
		$_ = <IN>;
		$line = $_;

		if ( $paramFlag == 1 ) {

			if ( /^\s*\**\s*\@/ || /^\s*\**\s*\*\// ) {
#parameter ends.
				$paramDesc{ $paramName } = $paramText;
				$paramFlag = 0;
			}
			else {
				/^\s*\**(.*)$/;
				$paramText .= $1."\n";
				$_ = "";
			}
		}
		elsif ( $retFlag == 1 ) {
			if ( /^\s*\**\s*\@/ || /^\s*\**\s*\*\// ) {
				$retFlag = 0;
			}
			else {
				/^\s*\*+(.*)$/;
				$retText .= "\n$1";
				$_ = "";
			}
		}

		if ( /^\s*(.*)\*+\// ) {
# end of member documentation
			$endDocBlock = 1;
		}
		elsif ( /^(.*)\*+\/\s*$/ && ($strictParser == 0) ) {
# end of member documentation, with extraneous
# space before end tag
# only used if we're being lenient.

			$text = $text .  $_ . '\n';

			$endDocBlock = 1;

			print "BAD MEMBER END: $_\n" if $debug == 1;
		}
		elsif ( /^\s*\**\s*\@param\s+([^\s]+)\s(.*)$/ ) {
# "@param"
			$paramName = $1;
			$paramText = $2;

			$paramFlag = 1;
		}
		elsif ( /^\s*\**\s*\@return\s+(.*)/ ) {
# "@return"

			$retText = $1;
			$retFlag = 1;
		}
		elsif( /^\s*\**\s*\@internal/ ) {
# "@internal"
			$methInternal = 1;
		}
		elsif( /^\s*\**\s*\@deprecated/ ) {
# "@deprecated"
			$methDeprecated = 1;
		}
		elsif ( /^\s*\**\s*\@exception\s+([:#\w_~]+)/ ) {
# "@exception"
			$exceptions .= $1;
		}
		elsif ( /^\s*\**\s*\@see\s+([:#\w_~]+)/ ) {
# "@see"
			$see .= ", " if $see ne "";

			$c = $1;
			$see .= $c;
		}
		elsif( /^\s*\**\s*\@(short|author|version)/ ) {
# ignore tags that cannot exist in
# member doc
		}
		elsif ( /^\s*\**\s*(.*)$/ ) {
# normal member documentation text,
# " * blah blah"
			$text = $text. $1 . "\n";
		} # if
	} # while still in doc block
} # processMemberDoc
   
###########################################################
#
# Function
#  processFile #
###########################################################

sub processFile
{
	while ( <IN> )
	{
	    $line = $_;

	    	next if /^\s*$/;
	
		if( m#^\s*/\*[^*]# ) {
# skip multiline comment started with /* (but only one asterisk!)
			while( !/\*\// ) {
				$_ = <IN>;
			}
		}
		elsif ( m#^\s*/\*\*+\s*(.*)\*/\s*# && ($strictParser == 0) ) {
			# single-line "/**..*/" type doc line
			# not allowed by the spec but we'll let it pass 
			# if we're being lenient.
			resetMemberDoc();
			$classText = $1;
			$classShortText = $1;
			print "ONELINE classdoc: $text\n" if $debug == 1;
		}
		elsif( /^\s*#[\w\.-_]+/ ) {
			#### Preprocessor directive
			print "CPP: $_\n" if $debug;

			# skip lines carried on with \
			while( /\\\s*$/ ) {
				if( !($_ = <IN>) ) {
					die "Bad Finish";
				}
				print "CPP: Skipped: $_" if $debug;
			}
		}
	    elsif ( /^\s*\/\*\*+\s*(.*)$/ )
	    {
	    	# start of class doc comment
		$classSee = "";
		$classText = "";
		$classShortText = "";
		$lastLineBlank = 0;

		$classText = $1 if( $strictParser == 0 );

		$end = 0;
		while ( $end == 0 )
		{
		    $_ = <IN>;
		    $line = $_;

		    if ( /^\s*\*\// )
		    {
		    	# end of documentation, assume class
			# declaration is next.
			$end = 1;
		    }
		    elsif ( /^(.*)\*+\/\s*$/ && ($strictParser == 0) ) 
		    {
			# end of class documentation, with extraneous
			# space before end tag
			# only used if we are being lenient.

			$text = $text .  $1 . '\n';

			$end = 1;

			print "BAD CLASSDOC END: $_\n" if $debug == 1;
		    }
		    elsif ( /^\s*\**\s*\@see\s+([#\w_~]+)/ )
		    {
		    	# @see
			if ( $classSee ne "" )
			{
			    $classSee .= ", ";
			}
			$c = $1;
			$classSee .= $c;
		    }
		    elsif ( /^\s*\*?\s*\@author\s+(.*)/ )
		    {
		    	# @author
		    	$classAuthor .= $1 . " ";
		    }
		    elsif ( /^\s*\**\s*\@version\s+(.*)/ )
		    {
		    	# @version
		    	$classVersion .= $1 . " ";
		    }
		    elsif ( /^\s*\**\s*\@short\s+(.*)/ )
		    {
		    	# @short
			$classShortText .= $1 . " ";
		    }
		    elsif ( /^\s*\**\s*\@deprecated/ )
		    {
		    	# @deprecated
			$classDeprecated = 1;
		    }
		    elsif ( /^\s*\**\s*\@internal/ )
		    {
		    	# @internal
			$classInternal = 1;
		    }
		    elsif ( /^\s*\**(.*)$/ )
		    {
		    	# normal documentation text
			$lead = $1;

			# check for asterisk
			if ( /^\s*\*+/ ) {
				$classText .= $lead. "\n";
			}
			else {
				# preserve leading space.
				$classText .= $_. "\n";
			}
		    }
		}
                $_ = <IN>;
		$line = $_;
			       
	    } # documentation if

	    if ( /^(\s*template\s*<(([-\w,_\s]|<([-\w,+\s])+>)+)>)/ ) {
		    $classTmplArgs = $2;

		    ($resetme = $1);
		    $resetme =~ s/([\W])/\\$1/g;

		    s/$resetme//g;
	    }

	    if ( !(/;/) && /^\s*(class|struct)\s+([-\w_]+)(.*)$/ )
	    {

# class declaration begins.

		#TODO: skip class if it doesn't have documentation
		#and we aren't documenting NULL classes.

		    $class = $2;
		    ($classInherits = $3) =~ s#//.*##g;

			# handle template-instantiation class
		    if($classInherits =~
			    /^\s*(<([-\w,_\s]|<([-\w,+\s])+>)+>)/) {
			    $class .= $1;
			    $class =~ s/\s+//g;
		    }

		    $classInherits =~ s/<([-\w,_\s]|<([-\w,+\s])+>)+>//g;

		    print "\n   $class " unless $quiet;

# set default visibility
		if( $1 eq "class" ) {
			$access = "private";
		} else {
			$access = "public";
		}
	
# process everything in the class
		    processClass();
	    }

	} # outer file while

	close( IN );
}

#
#
#

sub addReference
{
	my( $target, $pointer) = @_;

	print KDOC $target."=".$pointer."\n";
	$classRef{ $target } = $pointer;
}

# Reset the documentation variables for a class member.

sub resetMemberDoc
{
    $exceptions	= "";
    %paramDesc	= ();
    $paramName	= "";
    $paramText	= "";
    $retText	= "";
    $see 	= "";
    $text 	= "";
    $methInternal = 0;
    $methDeprecated=0;
}

#
# Reset the documentation variables for a class.
#
sub resetClassDoc
{
	$classAuthor	= "";
	$classDeprecated= 0;
	$classInternal	= 0;
	$classSee	= "";
	$classShortText	= "";
	$classShortTextSet = 0;
	$classTmplArgs	= "";
	$classAbstract	= 0;
	$classText	= "";
	$classVersion	= "";
}

# Counts the number of times a regular expression occurs in a string

sub countReg
{
	my( $str, $regexp ) = @_;
	my( $count ) = 0;

	while( $str =~ /$regexp/ ) {
		$count++;
		
		$str =~ s/$regexp//;	
	}

	return $count;
}

#
# Display usage and quit with an error code.
#

sub usage
{
die<<EOF;

KDOC:	The KDE Class Documentation Tool for C++, $version
	Torben Weis <weis\@kde.org>, Sirtaj Kang <taj\@kde.org>

Usage:
	kdoc [-a] [-M][-H][-T] [-a][-e][-i][-p][-q] [-L<lib-path>] 
		[-d<outdir>] [-u <base URL>] <library> <header>...
		[-l<lib> ... ]

	-T	Generate LaTeX documentation.
	-M	Generate man pages.

	-H	Generate HTML documentation (default).
	-d<dir> Directory for HTML and LaTeX output.
	-u<url> Base path/url by which this library will be accessed.
	
	-a	Document methods/classes without explicit doc comment.
	-e	Skip deprecated methods and classes (\@deprecated tag)
	-i	Skip classes marked internal (\@internal tag)
	-p	Document private members.
	-q	Proceed quietly (display errors only)

	-L<dir>	Path to kdoc libraries. Default is current dir, or
		\$KDOCLIBS if it is set.

	<library> The name of the kdoc library to create.
	<headers> C++ headers to process.

	-l<lib>	Cross reference these libraries.
EOF
}

sub bumpArg
{
	return $1 if $1 ne "";
	my($real);

	$i = $i + 1;

	$real = $myargs[ $i ];
	$myargs[ $i ] = "-".$myargs[ $i ];


	return $real;
}


#
# Calls dumpDoc for each format for which output was requested.
#
 
sub generateDocs
{

	if( $genHTML == 0 && $genTeX == 0 && $genMan == 0)
	{
		$genHTML = 1;
		require kdocHTML;
	}

	if( $genHTML != 0 ) {
		kdocHTML::dumpDoc( $name, $rootNode, $docPath );
	}

	if( $genTeX != 0 ) {
		kdocTeX::dumpDoc( $name, $rootNode, $docPath );
	}

	if( $genMan != 0 ) {
		kdocMan::dumpDoc( $name, $rootNode, $docPath );
	}

	print "Done.\n" unless $quiet;
}

###########################################################
#
# Main
#
###########################################################

if ( $#ARGV == -1 )
{
	die "kdoc: No arguments. Type 'kdoc -h' for help.\n";
}

#
# process switches and args #
#

$libFoundAt = -1;

$i = 0;

while( $i <=$#myargs )
{
    $filename = $myargs[ $i ];
    if ( $filename =~ /^-d(.*)$/ ) {

	$docPath = bumpArg();
    }
    elsif ( $filename =~ /^-u(.*)$/ ) {
    	$urlBase= bumpArg();
    }
    elsif ( $filename =~ /^-L(.*)$/ ) {
	$libPath = bumpArg();    	
    }
    elsif ( $filename =~ /^-l(.*)$/ ) {
   	readLibrary( bumpArg() );
    }
    elsif ( $filename =~ /^-a/ ) {
    	$documentAll = 1;
    }
    elsif ( $filename =~ /^-M/ ) {
	    $genMan = 1;
	    require kdocMan;
    }
    elsif ( $filename =~ /^-T/ ) {
	    $genTeX = 1;
	    require kdocTeX;
    }
    elsif ( $filename =~ /^-H/ ) {
	    $genHTML = 1;
	    require kdocHTML;
    }
    elsif ( $filename =~ /^-e/ ) {
   	$docDeprecated = 0; 
    }
    elsif ( $filename =~ /^-D/ ) {
   	$debug = 1; 
    }
    elsif ( $filename =~ /^-i/ ) {
   	$docInternal = 0; 
    }
    elsif ( $filename =~ /^-p/ ) {
    	$dontDoPrivate = 0;
    }
    elsif ( $filename =~ /^-q/ ) {
    	$quiet = 1;
    }
    elsif( $filename =~ /^-v(.*)/  ) {
    	die "kdoc: $version (c) Torben Weis, Sirtaj S. Kang\n";
    }
    elsif( $filename =~ /^-h/ || $filename =~ /^--help/ )
    {
    	usage();
    }
    elsif( $filename =~ /^-(.*)/ ) {
    	die "kdoc: -$1 is an unsupported option. Type kdoc -h for help.\n";
    }
    elsif( $lib eq "" ) {
    	$lib = $filename;
	$libFoundAt = $i;
    }

    $i = $i + 1;
}

$urlBase = $docPath if $urlBase eq "";

usage() if $lib eq "";

#parse out path name for printed libName
( $name = $lib ) =~ s#.*/##g;

$lib = $libPath."/".$lib.".kdoc";

open( KDOC, ">$lib" ) || die "Could not open $lib for writing\n";
print KDOC "$urlBase\n";


# check document output path

if( !(-d $docPath))
{
	if( system("mkdir $docPath") ) {
		close ( KDOC );
		unlink( $lib );
		die "Document path '$docPath' doesn't exist and it couldn't\n".
			"be created.\n";
	}
}

#
# process each file
#

foreach $i (0..$#myargs)
{
    $filename = $myargs[ $i ];
    if ( $filename =~ /^-(.*)$/ )
    {
#option... don't process    	
    }
    elsif( $i != $libFoundAt )
    {
	print "Processing $filename:" unless $quiet;
	push( @headerList, $filename );
	open( IN, $filename ) || die "Could not open $filename for input\n";

	processFile();

	print "\n" unless $quiet;

	close( IN );
    }
}


close( KDOC );

# reparent all parentless classes to root.

$rootNode->Visit("main");

if( defined $classes ) {

	foreach $class ( @{$classes} )
	{
		$className = $class->{"astNodeName"};

		if ( !defined $parents{ $parents{$className} }) {
			addClass( "<>", $parents{$className} );
		}
	}
}

Ast::UnVisit();

generateDocs();

# file ends
