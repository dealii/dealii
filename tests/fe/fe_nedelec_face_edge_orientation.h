// ------------------------------------------------------------------------
//
// SPDX-License-Identifier: LGPL-2.1-or-later
// Copyright (C) 2013 - 2023 by the deal.II authors
//
// This file is part of the deal.II library.
//
// Part of the source code is dual licensed under Apache-2.0 WITH
// LLVM-exception OR LGPL-2.1-or-later. Detailed license information
// governing the source code and code contributions can be found in
// LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.
//
// ------------------------------------------------------------------------

// In general, vertices of a face can be incorporated into two neighbouring
// cells such that the face appears to have different orientations in the two
// cells. The code of deal.II compensates for such mismatch in face orientation.
// This code tests if deal.II does the compensation well for the Nedelec finite
// elements in two- and three-dimensional spaces on globally refined meshes.
//
// In the two-dimensional space the Nedelec finite elements have dofs associated
// with lines (edges) and the quad (the interior of the cell). Only line
// dofs are shared between the cells in 2D. In the three-dimensional space the
// Nedelec finite elements have dofs that are associated with lines (edges),
// quads (faces), and the hex (the interior of the cell). The dofs associated
// with lines and quads are shared between the cells in 3D. Therefore, the dofs
// affected by the mismatch in face orientation are:
// (i)   the line dofs in 2D,
// (ii)  the line dofs in 3D,
// (iii) the quad dofs in 3D.
//
// The shape functions that correspond to these three kinds of dofs share the
// same feature: they exhibit reflection symmetry in the shared face if the
// two cells that share the face are cubes (squares) of equal volume (area).
// The code below exploits this feature.
//
// First, a mesh with a particular face mismatch is generated. Second, all shape
// functions are sampled at sampling points. Indices of the sampling points in
// one cell is the mirrored image of the indices in the other cell. Third, the
// sampled shape functions are sorted in two categories: (i) shared between two
// cells and (ii) locked inside a cell. The locked shaped functions are ignored.
// The reflection symmetry of the shared shape functions is tested by computing
// a score coefficient which is a cumulative l2_norm of a difference between a
// sampled vector and its reflection. The score coefficient should be zero. The
// program logs the score coefficients and two versions of the total amount of
// shared dofs - one is theoretically expected, another is actually counted
// during the execution of the code.
//
// In the three-dimensional space deal.II encodes the mismatch in face
// orientation by three boolean parameters:
//
// (i)   face_orientation - true if face is in standard orientation.
// (ii)  face_rotation - rotation by 90 deg counterclockwise if true;
// (iii) face_flip - rotation by 180 deg counterclockwise if true.
//
// See the documentation of GeometryInfo<dim>.
//
// The combined face orientation is computes as
//
// orientation_no = face_flip*4 + face_rotation*2 + face_orientation*1;
//
// See tria_orientation.h.
//
// In the two-dimensional space the face orientation is encoded by
// one boolean parameter line_orientation. The parameter equals true if the
// faces have the same orientation.
//
// In this program the one parameter is used to encode the face orientation in
// two- and three- dimensions. This parameter is
//
// unsigned char combined_face_orientation;
//
// Interpretation of this parameter in three dimensions is straightforward:
// it is the combined face orientation as it is known in deal.II. In the
// two-dimensional space this parameter is interpreted as the following.
// The odd parameter (LSB = 1) implies that the shared faces (lines) are
// aligned. The even parameter (LSB = 0) implies that the shared faces point in
// opposite directions. That is, the least significant bit (LSB) of the
// combined_face_orientation parameter is interpreted as the
// line_orientation parameter which is used in deal.II on two-dimensional
// meshes.
//
// Test meshes in two and three dimensions are generated by functions
// GridGenerator::non_standard_orientation_mesh().
// The three-dimensional mesh is used as it is. Only the leftmost shared face
// is used in two dimensions. That is, shape functions are sampled only on
// the leftmost and the middle cells of the two-dimensional mesh.

#include <deal.II/base/quadrature_lib.h>

#include <deal.II/dofs/dof_handler.h>

#include <deal.II/fe/fe_nedelec.h>
#include <deal.II/fe/fe_values.h>

#include <deal.II/grid/grid_generator.h>
#include <deal.II/grid/grid_out.h>
#include <deal.II/grid/tria.h>
#include <deal.II/grid/tria_orientation.h>

#include <deal.II/lac/vector.h>

#include <deal.II/numerics/fe_field_function.h>
#include <deal.II/numerics/vector_tools.h>

#include <cmath>
#include <string>

#include "../tests.h"

template <int dim>
void
create_triangulation(Triangulation<dim> &triangulation,
                     const unsigned char combined_face_orientation);

template <int dim>
void
create_sampling_points(std::vector<Point<dim>> &sampling_points_left,
                       std::vector<Point<dim>> &sampling_points_right,
                       unsigned int             N);

template <int dim>
void
save_sampling_points(std::vector<Point<dim>> &sampling_points_left,
                     std::vector<Point<dim>> &sampling_points_right);

template <int dim>
void
print_shared_face(Triangulation<dim> &triangulation);

template <>
void
create_triangulation<2>(Triangulation<2>   &triangulation,
                        const unsigned char combined_face_orientation)

{
  // Only the leftmost shared face is considered. Even values of
  // combined_face_orientation produce misaligned faces (the middle square is
  // rotated by 2*[pi/2]). Odd values of combined_face_orientation produce
  // aligned faces (the middle square is not rotated).
  const unsigned int n_rotate_middle_square =
    (combined_face_orientation % 2 == 0) ? 2 : 0;

  GridGenerator::non_standard_orientation_mesh(triangulation,
                                               n_rotate_middle_square);
}

template <>
void
create_triangulation<3>(Triangulation<3>   &triangulation,
                        const unsigned char combined_face_orientation)

{
  bool face_orientation;
  bool face_rotation;
  bool face_flip;

  std::tie(face_orientation, face_rotation, face_flip) =
    dealii::internal::split_face_orientation(combined_face_orientation);

  GridGenerator::non_standard_orientation_mesh(
    triangulation, face_orientation, face_flip, face_rotation, false);
}

template <>
void
create_sampling_points<2>(std::vector<Point<2>> &sampling_points_left,
                          std::vector<Point<2>> &sampling_points_right,
                          unsigned int           N)
{
  const double offset = 0.1;
  const double step   = (1.0 - 2 * offset) / (N - 1);

  unsigned int indx = 0;

  for (unsigned int j = 0; j < N; j++)
    for (unsigned int i = 0; i < N; i++)
      {
        indx = i + N * j;

        sampling_points_left.at(indx)[0] = offset + step * i;
        sampling_points_left.at(indx)[1] = offset + step * j;

        sampling_points_right.at(indx)[0] =
          2.0 - sampling_points_left.at(indx)[0];
        sampling_points_right.at(indx)[1] = sampling_points_left.at(indx)[1];
      }
}

template <>
void
create_sampling_points<3>(std::vector<Point<3>> &sampling_points_left,
                          std::vector<Point<3>> &sampling_points_right,
                          unsigned int           N)
{
  const double offset = 0.1;
  const double step   = (1.0 - 2 * offset) / (N - 1);

  unsigned int indx = 0;

  for (unsigned int k = 0; k < N; k++)
    for (unsigned int j = 0; j < N; j++)
      for (unsigned int i = 0; i < N; i++)
        {
          indx = i + N * j + N * N * k;

          sampling_points_left.at(indx)[0] = offset + step * i;
          sampling_points_left.at(indx)[1] = offset + step * j;
          sampling_points_left.at(indx)[2] = offset + step * k;

          sampling_points_right.at(indx)[0] =
            2.0 - sampling_points_left.at(indx)[0];
          sampling_points_right.at(indx)[1] = sampling_points_left.at(indx)[1];
          sampling_points_right.at(indx)[2] = sampling_points_left.at(indx)[2];
        }
}

template <int dim>
void
save_mesh(Triangulation<dim> &triangulation)
{
  GridOut           gridout;
  GridOutFlags::Msh msh_flags(true, true);
  gridout.set_flags(msh_flags);

  std::ofstream ofs("mesh_" + std::to_string(dim) + "D.msh");
  gridout.write_msh(triangulation, ofs);
}

template <>
void
save_sampling_points<2>(std::vector<Point<2>> &sampling_points_left,
                        std::vector<Point<2>> &sampling_points_right)
{
  std::ofstream ofs_left("sampling_points_left_2D.csv");
  std::ofstream ofs_right("sampling_points_right_2D.csv");

  for (unsigned int i = 0; i < sampling_points_left.size(); i++)
    {
      ofs_left << sampling_points_left.at(i)[0] << " , "
               << sampling_points_left.at(i)[1] << std::endl;

      ofs_right << sampling_points_right.at(i)[0] << " , "
                << sampling_points_right.at(i)[1] << std::endl;
    }

  ofs_left.close();
  ofs_right.close();
}

template <>
void
save_sampling_points<3>(std::vector<Point<3>> &sampling_points_left,
                        std::vector<Point<3>> &sampling_points_right)
{
  std::ofstream ofs_left("sampling_points_left_3D.csv");
  std::ofstream ofs_right("sampling_points_right_3D.csv");

  for (unsigned int i = 0; i < sampling_points_left.size(); i++)
    {
      ofs_left << sampling_points_left.at(i)[0] << " , "
               << sampling_points_left.at(i)[1] << " , "
               << sampling_points_left.at(i)[2] << std::endl;

      ofs_right << sampling_points_right.at(i)[0] << " , "
                << sampling_points_right.at(i)[1] << " , "
                << sampling_points_right.at(i)[2] << std::endl;
    }

  ofs_left.close();
  ofs_right.close();
}

template <>
void
print_shared_face(Triangulation<2> &triangulation)
{
  const double eps = 1e-12;

  for (const auto &cell : triangulation.active_cell_iterators())
    for (unsigned int f = 0; f < 4; f++)
      if (cell->neighbor_index(f) != -1)
        if (((cell->face(f)->center()(0) - 1.0) < eps) &&
            ((cell->face(f)->center()(1) - 0.5) < eps))
          {
            std::cout << "Cell center = (" << cell->center() << ")"
                      << std::endl;
            std::cout << "The local index of the shared face: " << f
                      << std::endl;
            std::cout << "Shared face - orientation: "
                      << cell->line_orientation(f) << std::endl;
          }
}

template <>
void
print_shared_face<3>(Triangulation<3> &triangulation)
{
  for (const auto &cell : triangulation.active_cell_iterators())
    {
      unsigned int face = -1;

      for (unsigned int f = 0; f < 6; f++)
        if (cell->neighbor_index(f) != -1)
          face = f;

      std::cout << "Cell id = " << cell->id() << ": " << std::endl;

      std::cout << "The local index of the shared face: " << face << std::endl;

      std::cout << "Shared face - flip: " << cell->face_flip(face) << std::endl;
      std::cout << "Shared face - rotation: " << cell->face_rotation(face)
                << std::endl;
      std::cout << "Shared face - orientation: " << cell->face_orientation(face)
                << std::endl;
      std::cout
        << "Shared face - combined orientation: "
        << static_cast<unsigned int>(
             internal::combined_face_orientation(cell->face_orientation(face),
                                                 cell->face_rotation(face),
                                                 cell->face_flip(face)))
        << std::endl;
    }
}

struct SFData
{
  bool   shared;
  bool   error;
  double cum_norm_left;
  double cum_norm_right;
  double cum_norm_diff;
};

void
classify(const std::vector<Vector<double>> &shape_function_left,
         const std::vector<Vector<double>> &shape_function_right,
         SFData                            &result)
{
  result.shared         = false;
  result.error          = false;
  result.cum_norm_left  = 0.0;
  result.cum_norm_right = 0.0;
  result.cum_norm_diff  = 0.0;

  double th  = 1e-3;
  double eps = 1e-12;

  unsigned int v_size = shape_function_left.size();
  for (unsigned int i = 0; i < v_size; i++)
    {
      result.cum_norm_left += shape_function_left.at(i).l2_norm();
      result.cum_norm_right += shape_function_right.at(i).l2_norm();

      Vector<double> diff(shape_function_left.at(i));

      diff.add(-1.0, shape_function_right.at(i));

      result.cum_norm_diff += diff.l2_norm();
    }

  double s_v_size = std::sqrt(v_size);

  result.cum_norm_left /= s_v_size;
  result.cum_norm_right /= s_v_size;
  result.cum_norm_diff /= s_v_size;

  if ((result.cum_norm_left > th) && (result.cum_norm_right > th))
    result.shared = true;

  if (result.shared)
    if (result.cum_norm_diff > eps)
      result.error = true;
}

template <int dim, unsigned int order>
void
run(unsigned char combined_face_orientation)
{
  Triangulation<dim> triangulation;

  create_triangulation<dim>(triangulation, combined_face_orientation);

  // save_mesh<dim>(triangulation);

  // print_shared_face<dim>(triangulation);

  FE_Nedelec<dim> fe(order);

  DoFHandler<dim> dof_handler(triangulation);

  dof_handler.distribute_dofs(fe);

  unsigned int N = order + 2;
  unsigned int M = static_cast<unsigned int>(std::pow(N, dim));

  std::vector<Point<dim>> sampling_points_left(M, Point<dim>());
  std::vector<Point<dim>> sampling_points_right(M, Point<dim>());

  std::vector<Vector<double>> shape_function_left(M, Vector<double>(dim));
  std::vector<Vector<double>> shape_function_right(M, Vector<double>(dim));

  create_sampling_points<dim>(sampling_points_left, sampling_points_right, N);

  // save_sampling_points<dim>(sampling_points_left, sampling_points_right);

  Vector<double> solution(dof_handler.n_dofs());

  dealii::Functions::FEFieldFunction field_function(dof_handler, solution);

  unsigned int n_shared_dofs_theory;

  if (dim == 2)
    n_shared_dofs_theory = order + 1;

  if (dim == 3)
    n_shared_dofs_theory = (2 * order + 1) * (order + 1);

  unsigned int Q             = solution.size();
  unsigned int n_shared_dofs = 0;
  for (unsigned int i = 0; i < Q; i++)
    {
      solution.reinit(Q);
      solution(i) = 1.0;

      field_function.vector_value_list(sampling_points_left,
                                       shape_function_left);
      field_function.vector_value_list(sampling_points_right,
                                       shape_function_right);

      SFData result;
      classify(shape_function_left, shape_function_right, result);

      if (result.error)
        deallog << "error: " << result.cum_norm_left << "   "
                << result.cum_norm_right << "   " << result.cum_norm_diff
                << std::endl;

      if ((result.shared) && (!result.error))
        {
          n_shared_dofs++;
          deallog << result.cum_norm_diff << std::endl;
        }


      if (n_shared_dofs == n_shared_dofs_theory)
        break;
    }

  deallog << n_shared_dofs << " : " << n_shared_dofs_theory << std::endl;
}
