// ------------------------------------------------------------------------
//
// SPDX-License-Identifier: LGPL-2.1-or-later
// Copyright (C) 2020 - 2026 by the deal.II authors
//
// This file is part of the deal.II library.
//
// Part of the source code is dual licensed under Apache-2.0 WITH
// LLVM-exception OR LGPL-2.1-or-later. Detailed license information
// governing the source code and code contributions can be found in
// LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.
//
// ------------------------------------------------------------------------


// Test PolynomialsPyramid by comparing it to a implementation for linear and
// quadratic polynomials


#include <deal.II/base/polynomials_pyramid.h>
#include <deal.II/base/quadrature_lib.h>

#include <deal.II/fe/fe_pyramid_p.h>

#include "../tests.h"



template <int dim>
double
compute_value(const unsigned int i, const Point<dim> &p)
{
  const double Q14 = 0.25;
  double       ration;

  const double r = p[0];
  const double s = p[1];
  const double t = p[2];

  if (std::fabs(t - 1.0) > 1.0e-14)
    {
      ration = (r * s * t) / (1.0 - t);
    }
  else
    {
      ration = 0.0;
    }

  if (i == 0)
    return Q14 * ((1.0 - r) * (1.0 - s) - t + ration);
  if (i == 1)
    return Q14 * ((1.0 + r) * (1.0 - s) - t - ration);
  if (i == 2)
    return Q14 * ((1.0 - r) * (1.0 + s) - t - ration);
  if (i == 3)
    return Q14 * ((1.0 + r) * (1.0 + s) - t + ration);
  else
    return t;
}


template <int dim>
double
compute_value_quadratic(const unsigned int i, const Point<dim> &p)
{
  const double x = p[0];
  const double y = p[1];
  const double z = p[2];

  if (std::abs(p[2] - 1.0) < 1e-12)
    {
      if (i == 4)
        return 1.0;
      else
        return 0.0;
    }

  switch (i)
    {
      case 0:
        return (0.25 * (x * x) * (y * y) + 0.25 * (x * x) * y * z -
                0.25 * (x * x) * y + 8.32667268468867e-17 * (x * x) * (z * z) -
                1.66533453693773e-16 * (x * x) * z +
                8.32667268468867e-17 * (x * x) + 0.25 * x * (y * y) * z -
                0.25 * x * (y * y) + 0.5 * x * y * (z * z) - 0.75 * x * y * z +
                0.25 * x * y + 0.25 * x * (z * z * z) - 0.5 * x * (z * z) +
                0.25 * x * z - 4.16333634234434e-17 * x -
                1.38777878078145e-17 * (y * y) * (z * z) +
                2.77555756156289e-17 * (y * y) * z -
                1.38777878078145e-17 * (y * y) + 0.25 * y * (z * z * z) -
                0.5 * y * (z * z) + 0.25 * y * z - 4.16333634234434e-17 * y +
                0.25 * (z * z * z * z) - 0.75 * (z * z * z) + 0.75 * (z * z) -
                0.25 * z - 2.77555756156289e-17) /
               (1.0 * (z * z) - 2.0 * z + 1.0);
      case 1:
        return (0.25 * (x * x) * (y * y) + 0.25 * (x * x) * y * z -
                0.25 * (x * x) * y + 8.32667268468867e-17 * (x * x) * (z * z) -
                1.66533453693773e-16 * (x * x) * z +
                8.32667268468867e-17 * (x * x) - 0.25 * x * (y * y) * z +
                0.25 * x * (y * y) - 0.5 * x * y * (z * z) + 0.75 * x * y * z -
                0.25 * x * y - 0.25 * x * (z * z * z) + 0.5 * x * (z * z) -
                0.25 * x * z + 4.16333634234434e-17 * x +
                1.38777878078145e-17 * (y * y) * (z * z) -
                2.77555756156289e-17 * (y * y) * z +
                1.38777878078145e-17 * (y * y) + 0.25 * y * (z * z * z) -
                0.5 * y * (z * z) + 0.25 * y * z - 6.93889390390723e-17 * y +
                0.25 * (z * z * z * z) - 0.75 * (z * z * z) + 0.75 * (z * z) -
                0.25 * z) /
               (1.0 * (z * z) - 2.0 * z + 1.0);
      case 2:
        return (0.25 * (x * x) * (y * y) - 0.25 * (x * x) * y * z +
                0.25 * (x * x) * y + 0.25 * x * (y * y) * z -
                0.25 * x * (y * y) - 0.5 * x * y * (z * z) + 0.75 * x * y * z -
                0.25 * x * y + 0.25 * x * (z * z * z) - 0.5 * x * (z * z) +
                0.25 * x * z - 1.38777878078145e-17 * x +
                1.38777878078145e-17 * (y * y) * (z * z) -
                2.77555756156289e-17 * (y * y) * z +
                1.38777878078145e-17 * (y * y) - 0.25 * y * (z * z * z) +
                0.5 * y * (z * z) - 0.25 * y * z + 2.77555756156289e-17 * y +
                0.25 * (z * z * z * z) - 0.75 * (z * z * z) + 0.75 * (z * z) -
                0.25 * z - 2.77555756156289e-17) /
               (1.0 * (z * z) - 2.0 * z + 1.0);
      case 3:
        return (0.25 * (x * x) * (y * y) - 0.25 * (x * x) * y * z +
                0.25 * (x * x) * y - 0.25 * x * (y * y) * z +
                0.25 * x * (y * y) + 0.5 * x * y * (z * z) - 0.75 * x * y * z +
                0.25 * x * y - 0.25 * x * (z * z * z) + 0.5 * x * (z * z) -
                0.25 * x * z + 1.38777878078145e-17 * x +
                1.38777878078145e-17 * (y * y) * (z * z) -
                2.77555756156289e-17 * (y * y) * z +
                1.38777878078145e-17 * (y * y) - 0.25 * y * (z * z * z) +
                0.5 * y * (z * z) - 0.25 * y * z + 2.77555756156289e-17 * y +
                0.25 * (z * z * z * z) - 0.75 * (z * z * z) + 0.75 * (z * z) -
                0.25 * z + 2.77555756156289e-17) /
               (1.0 * (z * z) - 2.0 * z + 1.0);
      case 4:
        return 1.0 * z *
               (-8.32667268468868e-18 * x * y + 8.32667268468868e-18 * x * z -
                8.32667268468868e-18 * x + 8.32667268468868e-18 * y * z -
                8.32667268468868e-18 * y + 2.0 * (z * z) - 3.0 * z + 1.0) /
               (z - 1);
      case 5:
        return (-0.5 * (x * x) * (y * y) + 0.5 * (x * x) * (z * z) -
                1.0 * (x * x) * z + 0.5 * (x * x) - 0.5 * x * (y * y) * z +
                0.5 * x * (y * y) - 1.38777878078145e-17 * x * y * (z * z) +
                1.38777878078145e-17 * x * y * z + 0.5 * x * (z * z * z) -
                1.5 * x * (z * z) + 1.5 * x * z - 0.5 * x -
                2.77555756156289e-17 * (y * y) * (z * z) +
                5.55111512312578e-17 * (y * y) * z -
                2.77555756156289e-17 * (y * y) +
                1.38777878078145e-17 * y * (z * z * z) -
                2.77555756156289e-17 * y * (z * z) +
                1.38777878078145e-17 * y * z +
                5.55111512312578e-17 * (z * z * z * z) -
                2.77555756156289e-16 * (z * z * z) +
                3.88578058618805e-16 * (z * z) - 1.66533453693773e-16 * z +
                2.77555756156289e-17) /
               (1.0 * (z * z) - 2.0 * z + 1.0);
      case 6:
        return (-0.5 * (x * x) * (y * y) + 0.5 * (x * x) * (z * z) -
                1.0 * (x * x) * z + 0.5 * (x * x) + 0.5 * x * (y * y) * z -
                0.5 * x * (y * y) + 1.38777878078145e-17 * x * y * (z * z) -
                1.38777878078145e-17 * x * y * z - 0.5 * x * (z * z * z) +
                1.5 * x * (z * z) - 1.5 * x * z + 0.5 * x -
                2.77555756156289e-17 * (y * y) * (z * z) +
                5.55111512312578e-17 * (y * y) * z -
                2.77555756156289e-17 * (y * y) -
                1.38777878078145e-17 * y * (z * z * z) +
                2.77555756156289e-17 * y * (z * z) -
                1.38777878078145e-17 * y * z +
                2.77555756156289e-17 * (z * z * z * z) -
                2.4980018054066e-16 * (z * z * z) +
                3.88578058618805e-16 * (z * z) - 1.38777878078145e-16 * z) /
               (1.0 * (z * z) - 2.0 * z + 1.0);
      case 7:
        return (-0.5 * (x * x) * (y * y) - 0.5 * (x * x) * y * z +
                0.5 * (x * x) * y - 8.32667268468867e-17 * (x * x) * (z * z) +
                1.66533453693773e-16 * (x * x) * z -
                8.32667268468867e-17 * (x * x) + 0.5 * (y * y) * (z * z) -
                1.0 * (y * y) * z + 0.5 * (y * y) + 0.5 * y * (z * z * z) -
                1.5 * y * (z * z) + 1.5 * y * z - 0.5 * y -
                9.71445146547012e-17 * (z * z * z * z) +
                3.33066907387547e-16 * (z * z * z) -
                3.88578058618805e-16 * (z * z) + 3.33066907387547e-16 * z -
                1.11022302462516e-16) /
               (1.0 * (z * z) - 2.0 * z + 1.0);
      case 8:
        return (-0.5 * (x * x) * (y * y) + 0.5 * (x * x) * y * z -
                0.5 * (x * x) * y - 2.77555756156289e-17 * (x * x) * (z * z) +
                5.55111512312578e-17 * (x * x) * z -
                2.77555756156289e-17 * (x * x) + 0.5 * (y * y) * (z * z) -
                1.0 * (y * y) * z + 0.5 * (y * y) - 0.5 * y * (z * z * z) +
                1.5 * y * (z * z) - 1.5 * y * z + 0.5 * y +
                1.38777878078145e-17 * (z * z * z * z) -
                1.11022302462516e-16 * (z * z * z) +
                2.77555756156289e-16 * (z * z) - 2.22044604925031e-16 * z +
                9.71445146547012e-17) /
               (1.0 * (z * z) - 2.0 * z + 1.0);
      case 9:
        return 1.0 * z *
               (-1.0 * x * y - 1.0 * x * z + 1.0 * x - 1.0 * y * z + 1.0 * y -
                1.0 * (z * z) + 2.0 * z - 1.0) /
               (z - 1);
      case 10:
        return 1.0 * z *
               (1.0 * x * y + 1.0 * x * z - 1.0 * x - 1.0 * y * z + 1.0 * y -
                1.0 * (z * z) + 2.0 * z - 1.0) /
               (z - 1);
      case 11:
        return 1.0 * z *
               (1.0 * x * y - 1.0 * x * z + 1.0 * x + 1.0 * y * z - 1.0 * y -
                1.0 * (z * z) + 2.0 * z - 1.0) /
               (z - 1);
      case 12:
        return 1.0 * z *
               (-1.0 * x * y + 1.0 * x * z - 1.0 * x + 1.0 * y * z - 1.0 * y -
                1.0 * (z * z) + 2.0 * z - 1.0) /
               (z - 1);
      case 13:
        return (1.0 * (x * x) * (y * y) - 1.0 * (x * x) * (z * z) +
                2.0 * (x * x) * z - 1.0 * (x * x) - 1.0 * (y * y) * (z * z) +
                2.0 * (y * y) * z - 1.0 * (y * y) + 1.0 * (z * z * z * z) -
                4.0 * (z * z * z) + 6.0 * (z * z) - 4.0 * z + 1.0) /
               (1.0 * (z * z) - 2.0 * z + 1.0);
    }
  return -1.0;
}

template <int dim>
Tensor<1, dim>
compute_grad(const unsigned int i, const Point<dim> &p)
{
  Tensor<1, dim> grad;

  const double Q14 = 0.25;

  const double r = p[0];
  const double s = p[1];
  const double t = p[2];

  double rationdr;
  double rationds;
  double rationdt;

  if (std::fabs(t - 1.0) > 1.0e-14)
    {
      rationdr = s * t / (1.0 - t);
      rationds = r * t / (1.0 - t);
      rationdt = r * s / ((1.0 - t) * (1.0 - t));
    }
  else
    {
      rationdr = 1.0;
      rationds = 1.0;
      rationdt = 1.0;
    }


  if (i == 0)
    {
      grad[0] = Q14 * (-1.0 * (1.0 - s) + rationdr);
      grad[1] = Q14 * (-1.0 * (1.0 - r) + rationds);
      grad[2] = Q14 * (rationdt - 1.0);
    }
  else if (i == 1)
    {
      grad[0] = Q14 * (1.0 * (1.0 - s) - rationdr);
      grad[1] = Q14 * (-1.0 * (1.0 + r) - rationds);
      grad[2] = Q14 * (-1.0 * rationdt - 1.0);
    }
  else if (i == 2)
    {
      grad[0] = Q14 * (-1.0 * (1.0 + s) - rationdr);
      grad[1] = Q14 * (1.0 * (1.0 - r) - rationds);
      grad[2] = Q14 * (-1.0 * rationdt - 1.0);
    }
  else if (i == 3)
    {
      grad[0] = Q14 * (1.0 * (1.0 + s) + rationdr);
      grad[1] = Q14 * (1.0 * (1.0 + r) + rationds);
      grad[2] = Q14 * (rationdt - 1.0);
    }
  else if (i == 4)
    {
      grad[0] = 0.0;
      grad[1] = 0.0;
      grad[2] = 1.0;
    }
  else
    {
      DEAL_II_NOT_IMPLEMENTED();
    }

  return grad;
}


template <int dim>
Tensor<1, dim>
compute_grad_quadratic(const unsigned int i, const Point<dim> &p)
{
  Tensor<1, dim> grad;

  const double x = p[0];
  const double y = p[1];
  const double z = p[2];

  switch (i)
    {
      case 0:
        {
          grad[0] =
            (0.5 * x * (y * y) + 0.5 * x * y * z - 0.5 * x * y +
             1.66533453693773e-16 * x * (z * z) - 3.33066907387547e-16 * x * z +
             1.66533453693773e-16 * x + 0.25 * (y * y) * z - 0.25 * (y * y) +
             0.5 * y * (z * z) - 0.75 * y * z + 0.25 * y + 0.25 * (z * z * z) -
             0.5 * (z * z) + 0.25 * z - 4.16333634234434e-17) /
            (1.0 * (z * z) - 2.0 * z + 1.0);
          grad[1] =
            (0.5 * (x * x) * y + 0.25 * (x * x) * z - 0.25 * (x * x) +
             0.5 * x * y * z - 0.5 * x * y + 0.5 * x * (z * z) - 0.75 * x * z +
             0.25 * x - 2.77555756156289e-17 * y * (z * z) +
             5.55111512312578e-17 * y * z - 2.77555756156289e-17 * y +
             0.25 * (z * z * z) - 0.5 * (z * z) + 0.25 * z -
             4.16333634234434e-17) /
            (1.0 * (z * z) - 2.0 * z + 1.0);
          grad[2] =
            0.25 * (2.0 - 2.0 * z) *
              (0.25 * (x * x) * (y * y) + 0.25 * (x * x) * y * z -
               0.25 * (x * x) * y + 8.32667268468867e-17 * (x * x) * (z * z) -
               1.66533453693773e-16 * (x * x) * z +
               8.32667268468867e-17 * (x * x) + 0.25 * x * (y * y) * z -
               0.25 * x * (y * y) + 0.5 * x * y * (z * z) - 0.75 * x * y * z +
               0.25 * x * y + 0.25 * x * (z * z * z) - 0.5 * x * (z * z) +
               0.25 * x * z - 4.16333634234434e-17 * x -
               1.38777878078145e-17 * (y * y) * (z * z) +
               2.77555756156289e-17 * (y * y) * z -
               1.38777878078145e-17 * (y * y) + 0.25 * y * (z * z * z) -
               0.5 * y * (z * z) + 0.25 * y * z - 4.16333634234434e-17 * y +
               0.25 * (z * z * z * z) - 0.75 * (z * z * z) + 0.75 * (z * z) -
               0.25 * z - 2.77555756156289e-17) /
              ((0.5 * (z * z) - z + 0.5) * (0.5 * (z * z) - z + 0.5)) +
            (0.25 * (x * x) * y + 1.66533453693773e-16 * (x * x) * z -
             1.66533453693773e-16 * (x * x) + 0.25 * x * (y * y) +
             1.0 * x * y * z - 0.75 * x * y + 0.75 * x * (z * z) - 1.0 * x * z +
             0.25 * x - 2.77555756156289e-17 * (y * y) * z +
             2.77555756156289e-17 * (y * y) + 0.75 * y * (z * z) - 1.0 * y * z +
             0.25 * y + 1.0 * (z * z * z) - 2.25 * (z * z) + 1.5 * z - 0.25) /
              (1.0 * (z * z) - 2.0 * z + 1.0);
          return grad;
        }
      case 1:
        {
          grad[0] =
            (0.5 * x * (y * y) + 0.5 * x * y * z - 0.5 * x * y +
             1.66533453693773e-16 * x * (z * z) - 3.33066907387547e-16 * x * z +
             1.66533453693773e-16 * x - 0.25 * (y * y) * z + 0.25 * (y * y) -
             0.5 * y * (z * z) + 0.75 * y * z - 0.25 * y - 0.25 * (z * z * z) +
             0.5 * (z * z) - 0.25 * z + 4.16333634234434e-17) /
            (1.0 * (z * z) - 2.0 * z + 1.0);
          grad[1] =
            (0.5 * (x * x) * y + 0.25 * (x * x) * z - 0.25 * (x * x) -
             0.5 * x * y * z + 0.5 * x * y - 0.5 * x * (z * z) + 0.75 * x * z -
             0.25 * x + 2.77555756156289e-17 * y * (z * z) -
             5.55111512312578e-17 * y * z + 2.77555756156289e-17 * y +
             0.25 * (z * z * z) - 0.5 * (z * z) + 0.25 * z -
             6.93889390390723e-17) /
            (1.0 * (z * z) - 2.0 * z + 1.0);
          grad[2] =
            0.25 * (2.0 - 2.0 * z) *
              (0.25 * (x * x) * (y * y) + 0.25 * (x * x) * y * z -
               0.25 * (x * x) * y + 8.32667268468867e-17 * (x * x) * (z * z) -
               1.66533453693773e-16 * (x * x) * z +
               8.32667268468867e-17 * (x * x) - 0.25 * x * (y * y) * z +
               0.25 * x * (y * y) - 0.5 * x * y * (z * z) + 0.75 * x * y * z -
               0.25 * x * y - 0.25 * x * (z * z * z) + 0.5 * x * (z * z) -
               0.25 * x * z + 4.16333634234434e-17 * x +
               1.38777878078145e-17 * (y * y) * (z * z) -
               2.77555756156289e-17 * (y * y) * z +
               1.38777878078145e-17 * (y * y) + 0.25 * y * (z * z * z) -
               0.5 * y * (z * z) + 0.25 * y * z - 6.93889390390723e-17 * y +
               0.25 * (z * z * z * z) - 0.75 * (z * z * z) + 0.75 * (z * z) -
               0.25 * z) /
              ((0.5 * (z * z) - z + 0.5) * (0.5 * (z * z) - z + 0.5)) +
            (0.25 * (x * x) * y + 1.66533453693773e-16 * (x * x) * z -
             1.66533453693773e-16 * (x * x) - 0.25 * x * (y * y) -
             1.0 * x * y * z + 0.75 * x * y - 0.75 * x * (z * z) + 1.0 * x * z -
             0.25 * x + 2.77555756156289e-17 * (y * y) * z -
             2.77555756156289e-17 * (y * y) + 0.75 * y * (z * z) - 1.0 * y * z +
             0.25 * y + 1.0 * (z * z * z) - 2.25 * (z * z) + 1.5 * z - 0.25) /
              (1.0 * (z * z) - 2.0 * z + 1.0);
          return grad;
        }
      case 2:
        {
          grad[0] = (0.5 * x * (y * y) - 0.5 * x * y * z + 0.5 * x * y +
                     0.25 * (y * y) * z - 0.25 * (y * y) - 0.5 * y * (z * z) +
                     0.75 * y * z - 0.25 * y + 0.25 * (z * z * z) -
                     0.5 * (z * z) + 0.25 * z - 1.38777878078145e-17) /
                    (1.0 * (z * z) - 2.0 * z + 1.0);
          grad[1] =
            (0.5 * (x * x) * y - 0.25 * (x * x) * z + 0.25 * (x * x) +
             0.5 * x * y * z - 0.5 * x * y - 0.5 * x * (z * z) + 0.75 * x * z -
             0.25 * x + 2.77555756156289e-17 * y * (z * z) -
             5.55111512312578e-17 * y * z + 2.77555756156289e-17 * y -
             0.25 * (z * z * z) + 0.5 * (z * z) - 0.25 * z +
             2.77555756156289e-17) /
            (1.0 * (z * z) - 2.0 * z + 1.0);
          grad[2] =
            0.25 * (2.0 - 2.0 * z) *
              (0.25 * (x * x) * (y * y) - 0.25 * (x * x) * y * z +
               0.25 * (x * x) * y + 0.25 * x * (y * y) * z -
               0.25 * x * (y * y) - 0.5 * x * y * (z * z) + 0.75 * x * y * z -
               0.25 * x * y + 0.25 * x * (z * z * z) - 0.5 * x * (z * z) +
               0.25 * x * z - 1.38777878078145e-17 * x +
               1.38777878078145e-17 * (y * y) * (z * z) -
               2.77555756156289e-17 * (y * y) * z +
               1.38777878078145e-17 * (y * y) - 0.25 * y * (z * z * z) +
               0.5 * y * (z * z) - 0.25 * y * z + 2.77555756156289e-17 * y +
               0.25 * (z * z * z * z) - 0.75 * (z * z * z) + 0.75 * (z * z) -
               0.25 * z - 2.77555756156289e-17) /
              ((0.5 * (z * z) - z + 0.5) * (0.5 * (z * z) - z + 0.5)) +
            (-0.25 * (x * x) * y + 0.25 * x * (y * y) - 1.0 * x * y * z +
             0.75 * x * y + 0.75 * x * (z * z) - 1.0 * x * z + 0.25 * x +
             2.77555756156289e-17 * (y * y) * z -
             2.77555756156289e-17 * (y * y) - 0.75 * y * (z * z) + 1.0 * y * z -
             0.25 * y + 1.0 * (z * z * z) - 2.25 * (z * z) + 1.5 * z - 0.25) /
              (1.0 * (z * z) - 2.0 * z + 1.0);
          return grad;
        }
      case 3:
        {
          grad[0] = (0.5 * x * (y * y) - 0.5 * x * y * z + 0.5 * x * y -
                     0.25 * (y * y) * z + 0.25 * (y * y) + 0.5 * y * (z * z) -
                     0.75 * y * z + 0.25 * y - 0.25 * (z * z * z) +
                     0.5 * (z * z) - 0.25 * z + 1.38777878078145e-17) /
                    (1.0 * (z * z) - 2.0 * z + 1.0);
          grad[1] =
            (0.5 * (x * x) * y - 0.25 * (x * x) * z + 0.25 * (x * x) -
             0.5 * x * y * z + 0.5 * x * y + 0.5 * x * (z * z) - 0.75 * x * z +
             0.25 * x + 2.77555756156289e-17 * y * (z * z) -
             5.55111512312578e-17 * y * z + 2.77555756156289e-17 * y -
             0.25 * (z * z * z) + 0.5 * (z * z) - 0.25 * z +
             2.77555756156289e-17) /
            (1.0 * (z * z) - 2.0 * z + 1.0);
          grad[2] =
            0.25 * (2.0 - 2.0 * z) *
              (0.25 * (x * x) * (y * y) - 0.25 * (x * x) * y * z +
               0.25 * (x * x) * y - 0.25 * x * (y * y) * z +
               0.25 * x * (y * y) + 0.5 * x * y * (z * z) - 0.75 * x * y * z +
               0.25 * x * y - 0.25 * x * (z * z * z) + 0.5 * x * (z * z) -
               0.25 * x * z + 1.38777878078145e-17 * x +
               1.38777878078145e-17 * (y * y) * (z * z) -
               2.77555756156289e-17 * (y * y) * z +
               1.38777878078145e-17 * (y * y) - 0.25 * y * (z * z * z) +
               0.5 * y * (z * z) - 0.25 * y * z + 2.77555756156289e-17 * y +
               0.25 * (z * z * z * z) - 0.75 * (z * z * z) + 0.75 * (z * z) -
               0.25 * z + 2.77555756156289e-17) /
              ((0.5 * (z * z) - z + 0.5) * (0.5 * (z * z) - z + 0.5)) +
            (-0.25 * (x * x) * y - 0.25 * x * (y * y) + 1.0 * x * y * z -
             0.75 * x * y - 0.75 * x * (z * z) + 1.0 * x * z - 0.25 * x +
             2.77555756156289e-17 * (y * y) * z -
             2.77555756156289e-17 * (y * y) - 0.75 * y * (z * z) + 1.0 * y * z -
             0.25 * y + 1.0 * (z * z * z) - 2.25 * (z * z) + 1.5 * z - 0.25) /
              (1.0 * (z * z) - 2.0 * z + 1.0);
          return grad;
        }
      case 4:
        {
          grad[0] = 1.0 * z *
                    (-8.32667268468868e-18 * y + 8.32667268468868e-18 * z -
                     8.32667268468868e-18) /
                    (z - 1);
          grad[1] = 1.0 * z *
                    (-8.32667268468868e-18 * x + 8.32667268468868e-18 * z -
                     8.32667268468868e-18) /
                    (z - 1);
          grad[2] =
            1.0 * z *
              (8.32667268468868e-18 * x + 8.32667268468868e-18 * y + 4.0 * z -
               3.0) /
              (z - 1) -
            1.0 * z *
              (-8.32667268468868e-18 * x * y + 8.32667268468868e-18 * x * z -
               8.32667268468868e-18 * x + 8.32667268468868e-18 * y * z -
               8.32667268468868e-18 * y + 2.0 * (z * z) - 3.0 * z + 1.0) /
              ((z - 1) * (z - 1)) +
            1.0 *
              (-8.32667268468868e-18 * x * y + 8.32667268468868e-18 * x * z -
               8.32667268468868e-18 * x + 8.32667268468868e-18 * y * z -
               8.32667268468868e-18 * y + 2.0 * (z * z) - 3.0 * z + 1.0) /
              (z - 1);
          return grad;
        }
      case 5:
        {
          grad[0] =
            (-1.0 * x * (y * y) + 1.0 * x * (z * z) - 2.0 * x * z + 1.0 * x -
             0.5 * (y * y) * z + 0.5 * (y * y) -
             1.38777878078145e-17 * y * (z * z) + 1.38777878078145e-17 * y * z +
             0.5 * (z * z * z) - 1.5 * (z * z) + 1.5 * z - 0.5) /
            (1.0 * (z * z) - 2.0 * z + 1.0);
          grad[1] =
            (-1.0 * (x * x) * y - 1.0 * x * y * z + 1.0 * x * y -
             1.38777878078145e-17 * x * (z * z) + 1.38777878078145e-17 * x * z -
             5.55111512312578e-17 * y * (z * z) + 1.11022302462516e-16 * y * z -
             5.55111512312578e-17 * y + 1.38777878078145e-17 * (z * z * z) -
             2.77555756156289e-17 * (z * z) + 1.38777878078145e-17 * z) /
            (1.0 * (z * z) - 2.0 * z + 1.0);
          grad[2] =
            0.25 * (2.0 - 2.0 * z) *
              (-0.5 * (x * x) * (y * y) + 0.5 * (x * x) * (z * z) -
               1.0 * (x * x) * z + 0.5 * (x * x) - 0.5 * x * (y * y) * z +
               0.5 * x * (y * y) - 1.38777878078145e-17 * x * y * (z * z) +
               1.38777878078145e-17 * x * y * z + 0.5 * x * (z * z * z) -
               1.5 * x * (z * z) + 1.5 * x * z - 0.5 * x -
               2.77555756156289e-17 * (y * y) * (z * z) +
               5.55111512312578e-17 * (y * y) * z -
               2.77555756156289e-17 * (y * y) +
               1.38777878078145e-17 * y * (z * z * z) -
               2.77555756156289e-17 * y * (z * z) +
               1.38777878078145e-17 * y * z +
               5.55111512312578e-17 * (z * z * z * z) -
               2.77555756156289e-16 * (z * z * z) +
               3.88578058618805e-16 * (z * z) - 1.66533453693773e-16 * z +
               2.77555756156289e-17) /
              ((0.5 * (z * z) - z + 0.5) * (0.5 * (z * z) - z + 0.5)) +
            (1.0 * (x * x) * z - 1.0 * (x * x) - 0.5 * x * (y * y) -
             2.77555756156289e-17 * x * y * z + 1.38777878078145e-17 * x * y +
             1.5 * x * (z * z) - 3.0 * x * z + 1.5 * x -
             5.55111512312578e-17 * (y * y) * z +
             5.55111512312578e-17 * (y * y) +
             4.16333634234434e-17 * y * (z * z) - 5.55111512312578e-17 * y * z +
             1.38777878078145e-17 * y + 2.22044604925031e-16 * (z * z * z) -
             8.32667268468867e-16 * (z * z) + 7.7715611723761e-16 * z -
             1.66533453693773e-16) /
              (1.0 * (z * z) - 2.0 * z + 1.0);
          return grad;
        }
      case 6:
        {
          grad[0] =
            (-1.0 * x * (y * y) + 1.0 * x * (z * z) - 2.0 * x * z + 1.0 * x +
             0.5 * (y * y) * z - 0.5 * (y * y) +
             1.38777878078145e-17 * y * (z * z) - 1.38777878078145e-17 * y * z -
             0.5 * (z * z * z) + 1.5 * (z * z) - 1.5 * z + 0.5) /
            (1.0 * (z * z) - 2.0 * z + 1.0);
          grad[1] =
            (-1.0 * (x * x) * y + 1.0 * x * y * z - 1.0 * x * y +
             1.38777878078145e-17 * x * (z * z) - 1.38777878078145e-17 * x * z -
             5.55111512312578e-17 * y * (z * z) + 1.11022302462516e-16 * y * z -
             5.55111512312578e-17 * y - 1.38777878078145e-17 * (z * z * z) +
             2.77555756156289e-17 * (z * z) - 1.38777878078145e-17 * z) /
            (1.0 * (z * z) - 2.0 * z + 1.0);
          grad[2] =
            0.25 * (2.0 - 2.0 * z) *
              (-0.5 * (x * x) * (y * y) + 0.5 * (x * x) * (z * z) -
               1.0 * (x * x) * z + 0.5 * (x * x) + 0.5 * x * (y * y) * z -
               0.5 * x * (y * y) + 1.38777878078145e-17 * x * y * (z * z) -
               1.38777878078145e-17 * x * y * z - 0.5 * x * (z * z * z) +
               1.5 * x * (z * z) - 1.5 * x * z + 0.5 * x -
               2.77555756156289e-17 * (y * y) * (z * z) +
               5.55111512312578e-17 * (y * y) * z -
               2.77555756156289e-17 * (y * y) -
               1.38777878078145e-17 * y * (z * z * z) +
               2.77555756156289e-17 * y * (z * z) -
               1.38777878078145e-17 * y * z +
               2.77555756156289e-17 * (z * z * z * z) -
               2.4980018054066e-16 * (z * z * z) +
               3.88578058618805e-16 * (z * z) - 1.38777878078145e-16 * z) /
              ((0.5 * (z * z) - z + 0.5) * (0.5 * (z * z) - z + 0.5)) +
            (1.0 * (x * x) * z - 1.0 * (x * x) + 0.5 * x * (y * y) +
             2.77555756156289e-17 * x * y * z - 1.38777878078145e-17 * x * y -
             1.5 * x * (z * z) + 3.0 * x * z - 1.5 * x -
             5.55111512312578e-17 * (y * y) * z +
             5.55111512312578e-17 * (y * y) -
             4.16333634234434e-17 * y * (z * z) + 5.55111512312578e-17 * y * z -
             1.38777878078145e-17 * y + 1.11022302462516e-16 * (z * z * z) -
             7.49400541621981e-16 * (z * z) + 7.7715611723761e-16 * z -
             1.38777878078145e-16) /
              (1.0 * (z * z) - 2.0 * z + 1.0);
          return grad;
        }
      case 7:
        {
          grad[0] = (-1.0 * x * (y * y) - 1.0 * x * y * z + 1.0 * x * y -
                     1.66533453693773e-16 * x * (z * z) +
                     3.33066907387547e-16 * x * z - 1.66533453693773e-16 * x) /
                    (1.0 * (z * z) - 2.0 * z + 1.0);
          grad[1] = (-1.0 * (x * x) * y - 0.5 * (x * x) * z + 0.5 * (x * x) +
                     1.0 * y * (z * z) - 2.0 * y * z + 1.0 * y +
                     0.5 * (z * z * z) - 1.5 * (z * z) + 1.5 * z - 0.5) /
                    (1.0 * (z * z) - 2.0 * z + 1.0);
          grad[2] =
            0.25 * (2.0 - 2.0 * z) *
              (-0.5 * (x * x) * (y * y) - 0.5 * (x * x) * y * z +
               0.5 * (x * x) * y - 8.32667268468867e-17 * (x * x) * (z * z) +
               1.66533453693773e-16 * (x * x) * z -
               8.32667268468867e-17 * (x * x) + 0.5 * (y * y) * (z * z) -
               1.0 * (y * y) * z + 0.5 * (y * y) + 0.5 * y * (z * z * z) -
               1.5 * y * (z * z) + 1.5 * y * z - 0.5 * y -
               9.71445146547012e-17 * (z * z * z * z) +
               3.33066907387547e-16 * (z * z * z) -
               3.88578058618805e-16 * (z * z) + 3.33066907387547e-16 * z -
               1.11022302462516e-16) /
              ((0.5 * (z * z) - z + 0.5) * (0.5 * (z * z) - z + 0.5)) +
            (-0.5 * (x * x) * y - 1.66533453693773e-16 * (x * x) * z +
             1.66533453693773e-16 * (x * x) + 1.0 * (y * y) * z -
             1.0 * (y * y) + 1.5 * y * (z * z) - 3.0 * y * z + 1.5 * y -
             3.88578058618805e-16 * (z * z * z) +
             9.99200722162641e-16 * (z * z) - 7.7715611723761e-16 * z +
             3.33066907387547e-16) /
              (1.0 * (z * z) - 2.0 * z + 1.0);
          return grad;
        }
      case 8:
        {
          grad[0] = (-1.0 * x * (y * y) + 1.0 * x * y * z - 1.0 * x * y -
                     5.55111512312578e-17 * x * (z * z) +
                     1.11022302462516e-16 * x * z - 5.55111512312578e-17 * x) /
                    (1.0 * (z * z) - 2.0 * z + 1.0);
          grad[1] = (-1.0 * (x * x) * y + 0.5 * (x * x) * z - 0.5 * (x * x) +
                     1.0 * y * (z * z) - 2.0 * y * z + 1.0 * y -
                     0.5 * (z * z * z) + 1.5 * (z * z) - 1.5 * z + 0.5) /
                    (1.0 * (z * z) - 2.0 * z + 1.0);
          grad[2] =
            0.25 * (2.0 - 2.0 * z) *
              (-0.5 * (x * x) * (y * y) + 0.5 * (x * x) * y * z -
               0.5 * (x * x) * y - 2.77555756156289e-17 * (x * x) * (z * z) +
               5.55111512312578e-17 * (x * x) * z -
               2.77555756156289e-17 * (x * x) + 0.5 * (y * y) * (z * z) -
               1.0 * (y * y) * z + 0.5 * (y * y) - 0.5 * y * (z * z * z) +
               1.5 * y * (z * z) - 1.5 * y * z + 0.5 * y +
               1.38777878078145e-17 * (z * z * z * z) -
               1.11022302462516e-16 * (z * z * z) +
               2.77555756156289e-16 * (z * z) - 2.22044604925031e-16 * z +
               9.71445146547012e-17) /
              ((0.5 * (z * z) - z + 0.5) * (0.5 * (z * z) - z + 0.5)) +
            (0.5 * (x * x) * y - 5.55111512312578e-17 * (x * x) * z +
             5.55111512312578e-17 * (x * x) + 1.0 * (y * y) * z -
             1.0 * (y * y) - 1.5 * y * (z * z) + 3.0 * y * z - 1.5 * y +
             5.55111512312578e-17 * (z * z * z) -
             3.33066907387547e-16 * (z * z) + 5.55111512312578e-16 * z -
             2.22044604925031e-16) /
              (1.0 * (z * z) - 2.0 * z + 1.0);
          return grad;
        }
      case 9:
        {
          grad[0] = 1.0 * z * (-1.0 * y - 1.0 * z + 1.0) / (z - 1);
          grad[1] = 1.0 * z * (-1.0 * x - 1.0 * z + 1.0) / (z - 1);
          grad[2] = 1.0 * z * (-1.0 * x - 1.0 * y - 2.0 * z + 2.0) / (z - 1) -
                    1.0 * z *
                      (-1.0 * x * y - 1.0 * x * z + 1.0 * x - 1.0 * y * z +
                       1.0 * y - 1.0 * (z * z) + 2.0 * z - 1.0) /
                      ((z - 1) * (z - 1)) +
                    1.0 *
                      (-1.0 * x * y - 1.0 * x * z + 1.0 * x - 1.0 * y * z +
                       1.0 * y - 1.0 * (z * z) + 2.0 * z - 1.0) /
                      (z - 1);
          return grad;
        }
      case 10:
        {
          grad[0] = 1.0 * z * (1.0 * y + 1.0 * z - 1.0) / (z - 1);
          grad[1] = 1.0 * z * (1.0 * x - 1.0 * z + 1.0) / (z - 1);
          grad[2] = 1.0 * z * (1.0 * x - 1.0 * y - 2.0 * z + 2.0) / (z - 1) -
                    1.0 * z *
                      (1.0 * x * y + 1.0 * x * z - 1.0 * x - 1.0 * y * z +
                       1.0 * y - 1.0 * (z * z) + 2.0 * z - 1.0) /
                      ((z - 1) * (z - 1)) +
                    1.0 *
                      (1.0 * x * y + 1.0 * x * z - 1.0 * x - 1.0 * y * z +
                       1.0 * y - 1.0 * (z * z) + 2.0 * z - 1.0) /
                      (z - 1);
          return grad;
        }
      case 11:
        {
          grad[0] = 1.0 * z * (1.0 * y - 1.0 * z + 1.0) / (z - 1);
          grad[1] = 1.0 * z * (1.0 * x + 1.0 * z - 1.0) / (z - 1);
          grad[2] = 1.0 * z * (-1.0 * x + 1.0 * y - 2.0 * z + 2.0) / (z - 1) -
                    1.0 * z *
                      (1.0 * x * y - 1.0 * x * z + 1.0 * x + 1.0 * y * z -
                       1.0 * y - 1.0 * (z * z) + 2.0 * z - 1.0) /
                      ((z - 1) * (z - 1)) +
                    1.0 *
                      (1.0 * x * y - 1.0 * x * z + 1.0 * x + 1.0 * y * z -
                       1.0 * y - 1.0 * (z * z) + 2.0 * z - 1.0) /
                      (z - 1);
          return grad;
        }
      case 12:
        {
          grad[0] = 1.0 * z * (-1.0 * y + 1.0 * z - 1.0) / (z - 1);
          grad[1] = 1.0 * z * (-1.0 * x + 1.0 * z - 1.0) / (z - 1);
          grad[2] = 1.0 * z * (1.0 * x + 1.0 * y - 2.0 * z + 2.0) / (z - 1) -
                    1.0 * z *
                      (-1.0 * x * y + 1.0 * x * z - 1.0 * x + 1.0 * y * z -
                       1.0 * y - 1.0 * (z * z) + 2.0 * z - 1.0) /
                      ((z - 1) * (z - 1)) +
                    1.0 *
                      (-1.0 * x * y + 1.0 * x * z - 1.0 * x + 1.0 * y * z -
                       1.0 * y - 1.0 * (z * z) + 2.0 * z - 1.0) /
                      (z - 1);
          return grad;
        }
      case 13:
        {
          grad[0] =
            (2.0 * x * (y * y) - 2.0 * x * (z * z) + 4.0 * x * z - 2.0 * x) /
            (1.0 * (z * z) - 2.0 * z + 1.0);
          grad[1] =
            (2.0 * (x * x) * y - 2.0 * y * (z * z) + 4.0 * y * z - 2.0 * y) /
            (1.0 * (z * z) - 2.0 * z + 1.0);
          grad[2] =
            0.25 * (2.0 - 2.0 * z) *
              (1.0 * (x * x) * (y * y) - 1.0 * (x * x) * (z * z) +
               2.0 * (x * x) * z - 1.0 * (x * x) - 1.0 * (y * y) * (z * z) +
               2.0 * (y * y) * z - 1.0 * (y * y) + 1.0 * (z * z * z * z) -
               4.0 * (z * z * z) + 6.0 * (z * z) - 4.0 * z + 1.0) /
              ((0.5 * (z * z) - z + 0.5) * (0.5 * (z * z) - z + 0.5)) +
            (-2.0 * (x * x) * z + 2.0 * (x * x) - 2.0 * (y * y) * z +
             2.0 * (y * y) + 4.0 * (z * z * z) - 12.0 * (z * z) + 12.0 * z -
             4.0) /
              (1.0 * (z * z) - 2.0 * z + 1.0);
          return grad;
        }
    }

  return grad;
}


template <int dim>
void
test_linear()
{
  FE_PyramidP<dim> fe_pyramid(1);
  const auto       support_points = fe_pyramid.get_unit_support_points();
  const auto       poly =
    ScalarLagrangePolynomialPyramid(1,
                                    fe_pyramid.n_dofs_per_cell(),
                                    support_points);

  const auto poly_linear = ScalarLagrangePolynomialPyramid<dim>(1);

  QGaussPyramid<dim> quad(2);

  for (unsigned int i = 0; i < quad.size(); ++i)
    for (unsigned int j = 0; j < 5; ++j)
      {
        const auto v1 = poly.compute_value(j, quad.point(i));
        const auto v2 = poly_linear.compute_value(j, quad.point(i));
        const auto v3 = compute_value(j, quad.point(i));

        if (std::abs(v3 - v1) < 1e-12)
          deallog << "ok"
                  << " ";
        else
          deallog << "Failure!!!";
        if (std::abs(v3 - v2) < 1e-12)
          deallog << "ok"
                  << " ";
        else
          deallog << "Failure!!!";
        deallog << std::endl;

        const auto g1 = poly.compute_grad(j, quad.point(i));
        const auto g2 = poly_linear.compute_grad(j, quad.point(i));
        const auto g3 = compute_grad(j, quad.point(i));

        for (unsigned int d = 0; d < dim; ++d)
          {
            if (std::abs((g3 - g1)[d]) < 1e-12)
              deallog << "ok ";
            else
              deallog << "Failure!!!";
            if (std::abs((g3 - g2)[d]) < 1e-12)
              deallog << "ok"
                      << " ";
            else
              deallog << "Failure!!!";
          }
        deallog << std::endl;
      }
}


template <int dim>
void
test_quadratic()
{
  FE_PyramidP<dim> fe_pyramid(2);
  const auto       support_points = fe_pyramid.get_unit_support_points();
  deallog << "N support points quadratic: " << support_points.size()
          << std::endl;
  const auto poly =
    ScalarLagrangePolynomialPyramid(2,
                                    fe_pyramid.n_dofs_per_cell(),
                                    support_points);

  std::vector<Point<dim>> points;
  for (const auto &p : support_points)
    points.emplace_back(p);
  points.erase(points.begin() +
               4); // remove the tip as there is no gradient defined
  // Add some random points
  points.emplace_back(Point<dim>(0.36658, 0.58775, 0.21455));
  points.emplace_back(Point<dim>(-0.64464, 0.3546, 0.3246));
  points.emplace_back(Point<dim>(0.0, 0.0, 0.99));

  // Add points from the quadrature
  QGaussPyramid<dim> quad(2);
  for (unsigned int i = 0; i < quad.size(); ++i)
    points.emplace_back(quad.point(i));

  for (unsigned int i = 0; i < points.size(); ++i)
    for (unsigned int j = 0; j < fe_pyramid.n_dofs_per_cell(); ++j)
      {
        const auto v1 = poly.compute_value(j, points[i]);
        const auto v2 = compute_value_quadratic(j, points[i]);
        if (std::abs(v2 - v1) < 1e-9)
          deallog << "ok ";
        else
          deallog << "Failure!!! " << i << " " << j << " " << v2 - v1
                  << std::endl;


        const auto g1 = poly.compute_grad(j, points[i]);
        const auto g2 = compute_grad_quadratic(j, points[i]);
        for (unsigned int d = 0; d < dim; ++d)
          {
            if (std::abs((g2 - g1)[d]) < 1e-9)
              deallog << "ok ";
            else
              deallog << "Failure!!! " << i << " " << j << " " << g2[d] << " "
                      << g1[d] << " " << d << std::endl;
          }
        deallog << std::endl;
      }
}


int
main()
{
  initlog();
  {
    deallog.push("3d-1");
    test_linear<3>();
    deallog.pop();
    deallog.push("3d-2");
    test_quadratic<3>();
    deallog.pop();
  }
}
