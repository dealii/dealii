// ------------------------------------------------------------------------
//
// SPDX-License-Identifier: LGPL-2.1-or-later
// Copyright (C) 2025 by the deal.II authors
//
// This file is part of the deal.II library.
//
// Part of the source code is dual licensed under Apache-2.0 WITH
// LLVM-exception OR LGPL-2.1-or-later. Detailed license information
// governing the source code and code contributions can be found in
// LICENSE.md and CONTRIBUTING.md at the top level directory of deal.II.
//
// ------------------------------------------------------------------------

#ifndef dealii_segment_data_out_h
#define dealii_segment_data_out_h

#include <deal.II/base/config.h>

#include <deal.II/base/data_out_base.h>
#include <deal.II/base/point.h>


DEAL_II_NAMESPACE_OPEN

/**
 * This class generates graphical output for line segment objects.
 *
 * Line segments are one-dimensional objects embedded in a @p dim dimensional
 * space. This class creates output data that can be visualized as lines in
 * visualization tools. Each segment is represented as a pair of Point<dim>
 * objects defining the start and end points.
 */
template <int dim>
class SegmentDataOut : public DataOutInterface<1, dim>
{
public:
  /**
   * Constructor.
   */
  SegmentDataOut() = default;

  /**
   * Destructor.
   */
  ~SegmentDataOut() = default;

  /**
   * Generate patches from a vector of line segments.
   *
   * @param segments A vector of line segments, where each segment is represented
   *        as a std::pair of two Point<dim> objects (start and end points).
   */
  void
  build_patches(const std::vector<std::pair<Point<dim>, Point<dim>>> &segments);

  /**
   * Attach data to each output patch that was generated by build_patches().
   *
   * The @p datasets parameter is expected to have the same size of the
   * container you used in the call to build_patches(), and each entry should
   * have the same size of the @p dataset_names argument.
   *
   * @param[in] datasets The actual data to attach to each patch
   * @param[in] dataset_names The name of each component of the dataset
   */
  void
  add_datasets(const std::vector<std::vector<double>> &datasets,
               const std::vector<std::string>         &dataset_names);

protected:
  // Copy doc
  virtual const std::vector<dealii::DataOutBase::Patch<1, dim>> &
  get_patches() const override;

  // Copy doc
  virtual std::vector<std::string>
  get_dataset_names() const override;

private:
  /**
   * The actual segments as patches.
   */
  std::vector<DataOutBase::Patch<1, dim>> patches;

  /**
   * Names of datasets.
   */
  std::vector<std::string> dataset_names;
};


// Template and inline functions
#ifndef DOXYGEN
template <int dim>
void
SegmentDataOut<dim>::build_patches(
  const std::vector<std::pair<Point<dim>, Point<dim>>> &segments)
{
  const unsigned int N = segments.size();

  dataset_names.clear();
  patches.resize(N);

  for (unsigned int i = 0; i < N; ++i)
    {
      // A line segment has 2 vertices
      patches[i].vertices[0]          = segments[i].first;
      patches[i].vertices[1]          = segments[i].second;
      patches[i].patch_index          = i;
      patches[i].n_subdivisions       = 1;
      patches[i].reference_cell       = ReferenceCells::get_hypercube<1>();
      patches[i].points_are_available = false;
    }
}



template <int dim>
void
SegmentDataOut<dim>::add_datasets(
  const std::vector<std::vector<double>> &datasets,
  const std::vector<std::string>         &names)
{
  AssertDimension(datasets.size(), patches.size());
  dataset_names = names;
  for (unsigned int i = 0; i < datasets.size(); ++i)
    {
      AssertDimension(datasets[i].size(), names.size());
      // For line segments, we have 2 vertices (start and end points)
      patches[i].data.reinit(names.size(), 2);
      for (unsigned int j = 0; j < names.size(); ++j)
        for (unsigned int k = 0; k < 2; ++k)
          patches[i].data(j, k) = datasets[i][j];
    }
}



template <int dim>
const std::vector<DataOutBase::Patch<1, dim>> &
SegmentDataOut<dim>::get_patches() const
{
  return patches;
}



template <int dim>
std::vector<std::string>
SegmentDataOut<dim>::get_dataset_names() const
{
  return dataset_names;
}

#endif

DEAL_II_NAMESPACE_CLOSE

#endif
