<h1>Results</h1>



The results of this program are not that interesting - after all
its purpose was not to demonstrate some new mathematical idea, and
also not how to program with deal.II, but rather to use the material
which we have developed in the previous examples to form something
which demonstrates a way to build modern finite element software in a
modular and extensible way.



Nevertheless, we of course show the results of the program. Of
foremost interest is the point value computation, for which we had
implemented the corresponding evaluation class. The results (i.e. the
output) of the program looks as follows:
@code
Running tests with "global" refinement criterion:
-------------------------------------------------
Refinement cycle: 0 1 2 3 4 5 6
DoFs  u(x_0)
   25 1.2868
   81 1.6945
  289 1.4658
 1089 1.5679
 4225 1.5882
16641 1.5932
66049 1.5945

Running tests with "kelly" refinement criterion:
------------------------------------------------
Refinement cycle: 0 1 2 3 4 5 6 7 8 9 10 11
DoFs  u(x_0)
   25 1.2868
   47 0.8775
   89 1.5365
  165 1.2974
  316 1.6442
  589 1.5221
 1093 1.5724
 2042 1.5627
 3766 1.5916
 7124 1.5876
13111 1.5942
24838 1.5932
@endcode


What surprises here is that the exact value is 1.59491554..., and that
it is apparently surprisingly complicated to compute the solution even to
only one per cent accuracy, although the solution is smooth (in fact
infinitely often differentiable). This smoothness is shown in the
graphical output generated by the program, here coarse grid and the
first 9 refinement steps of the Kelly refinement indicator:


<table width="80%" align="center">
  <tr>
    <td>
      <img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-0.png" alt="">
    </td>
    <td>
      <img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-1.png" alt="">
    </td>
  </tr>

  <tr>
    <td>
      <img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-2.png" alt="">
    </td>
    <td>
      <img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-3.png" alt="">
    </td>
  </tr>

  <tr>
    <td>
      <img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-4.png" alt="">
    </td>
    <td>
      <img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-5.png" alt="">
    </td>
  </tr>

  <tr>
    <td>
      <img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-6.png" alt="">
    </td>
    <td>
      <img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-7.png" alt="">
    </td>
  </tr>

  <tr>
    <td>
      <img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-8.png" alt="">
    </td>
    <td>
      <img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-9.png" alt="">
    </td>
  </tr>
</table>


While we're already at watching pictures, this is the eighth grid, as
viewed from top:


<img src="https://www.dealii.org/images/steps/developer/step-13.grid-kelly-8.png" alt="">


However, we are not yet finished with evaluation the point value
computation. In fact, plotting the error
$e=|u(x_0)-u_h(x_0)|$ for the two
refinement criteria yields the following picture:


<img src="https://www.dealii.org/images/steps/developer/step-13.error.png" alt="">




What <em>is</em> disturbing about this picture is that not only is the
adaptive mesh refinement not better than global refinement as one
would usually expect, it is even significantly worse since its
convergence is irregular, preventing all extrapolation techniques when
using the values of subsequent meshes! On the other hand, global
refinement provides a perfect $1/N$ or $h^{-2}$
convergence history and provides every opportunity to even improve on
the point values by extrapolation. Global mesh refinement must
therefore be considered superior in this example! This is even more
surprising as the evaluation point is not somewhere in the left part
where the mesh is coarse, but rather to the right and the adaptive
refinement should refine the mesh around the evaluation point as well.



We thus close the discussion of this example program with a question:

<p align="center">
  <strong><em>What is wrong with adaptivity if it is not better than
  global refinement?</em></strong>




<em>Exercise at the end of this example:</em> There is a simple reason
for the bad and irregular behavior of the adapted mesh solutions. It
is simple to find out by looking at the mesh around the evaluation
point in each of the steps - the data for this is in the output files
of the program. An exercise would therefore be to modify the mesh
refinement routine such that the problem (once you remark it) is
avoided. The second exercise is to check whether the results are then
better than global refinement, and if so if even a better order of
convergence (in terms of the number of degrees of freedom) is
achieved, or only by a better constant.



(<em>Very brief answers for the impatient:</em> at steps with larger
errors, the mesh is not regular at the point of evaluation, i.e. some
of the adjacent cells have hanging nodes; this destroys some
superapproximation effects of which the globally refined mesh can
profit. Answer 2: this quick hack
@code
    bool refinement_indicated = false;
    typename Triangulation<dim>::active_cell_iterator cell;
    for (cell=triangulation->begin_active();
	 cell!=triangulation->end(); ++cell)
      for (unsigned int v=0; v<GeometryInfo<dim>::vertices_per_cell; ++v)
	if (cell->vertex(v) == Point<dim>(.5,.5))
	  {
	    cell->clear_coarsen_flag();
	    refinement_indicated |= cell->refine_flag_set();
	  }
    if (refinement_indicated)
      for (cell=triangulation->begin_active();
	   cell!=triangulation->end(); ++cell)
	for (unsigned int v=0; v<GeometryInfo<dim>::vertices_per_cell; ++v)
	  if (cell->vertex(v) == Point<dim>(.5,.5))
	    cell->set_refine_flag ();
@endcode
in the refinement function of the Kelly refinement class right before
executing refinement would improve the results (exercise: what does
the code do?), making them consistently better than global
refinement. Behavior is still irregular, though, so no results about
an order of convergence are possible.)

