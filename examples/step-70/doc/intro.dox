<br>

<i>This program was contributed by Luca Heltai (SISSA, Trieste) and Bruno Blais (Polytechnique Montréal)
</i>

<b>Change this!!!!</b>

@dealiiTutorialDOI{10.5281/zenodo.1243280,https://zenodo.org/badge/DOI/10.5281/zenodo.1243280.svg}


<h1>Introduction</h1>

<h3>Non-matching grid simulations through a massively parallel and distributed Nitsche method</h3>


In this tutorial we consider the case of two domains, $\Omega$ in
$R^{\text{spacedim}}$ and $\Gamma$ in $R^{\text{dim}}$. The domain $\Gamma$ is
embedded in $\Omega$ ($\Gamma \subseteq \Omega$) and is not-matching. We want to solve a partial
differential equation on $\Omega$, enforcing some conditions on the solution of
the problem on the embedded domain $\Gamma$ using the Nitsche method.

The technique we describe here is presented in the literature using one of many names:
the <b>immersed finite element method</b> and the <b>fictitious boundary method</b> among others. The main principle is
that the discretization of the two grids and of the two finite element spaces
are kept completely independent. In the present tutorial, this approach is used to solve for the motion of a
viscous fluid, described by the Stokes equation, that is agitated by a rigid (non-deformable) impeller.
 Thus, the equations solved in $\Omega$ are the Stokes equations for a creeping
flow (i.e. a flow where $\text{Re}\rightarrow 0$) and a no-slip boundary
condition is applied on the moving *embedded domain* associated with
the impeller : $\Gamma$. However, this tutorial could be readily extended
to other equations (e.g. the Navier-Stokes equations, linear elasticity equation, etc.). It can
can be seen as a natural extension of step-60 that enables the solution
of large problems using distributed parallel computing architecture via MPI.

There are two interesting scenarios that occur when one wants to enforce
conditions on the embedded domain $\Gamma$:

- the geometrical dimension `dim` of the embedded domain $\Gamma$ is the same of
the domain $\Omega$ (`spacedim`), that is, the spacedim-dimensional measure of
$\Gamma$ is not zero, or

- the embedded domain $\Gamma$ has an intrinsic dimension `dim` which is smaller
than that of $\Omega$ (`spacedim`), thus its spacedim-dimensional measure is
zero; for example it is a curve embedded in a two dimensional domain, or a
surface embedded in a three-dimensional domain.

In this tutorial program we are not interested in further details on $\Gamma$: we
assume that the dimension of the
embedded domain (`dim`) is always smaller by one or equal with respect to the
dimension of the embedding domain $\Omega$ (`spacedim`).

We are going to solve the following differential problem: given a sufficiently
regular function $g$ on $\Gamma$, find the solution $(\textbf{u},p)$ to

@f{eqnarray*}
{
  -\Delta \mathbf{u} + \nabla p &=& 0,\\
  -\nabla \cdot \textbf{u} &=& 0,\\
  \textbf{u} &=& \textbf{g}  \text{ in } \Gamma,\\
  \textbf{u} &=& 0 \text{ on } \partial\Omega.
@f}

We are looking for a velocity field
 $\mathbf{u}$ and a pressure field $p$ that satisfies the Stokes equations
 on $\Omega$ and homogeneous boundary conditions on $\partial\Omega$.
  Additionally,  the velocity field is subject to the condition
  $\mathbf{u} = \mathbf{g}$ on  $\Gamma$ that is imposed weakly using
Nitsche method. The application of Nitsche's method will be discussed
furthermore once the variational formulation has been introduced.


The weak form of the Stokes equations is obtained by first writing it in vector form as

@f{eqnarray*}
  \begin{pmatrix}
    {-\Delta \textbf{u} + \nabla p}
    \\
    {-\nabla \cdot \textbf{u}}
  \end{pmatrix}
  =
  \begin{pmatrix}
  {0
  \\
  0
  \end{pmatrix},
@f}
forming the dot product from the left with a vector-valued test
function $\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}$ and integrating
over the domain $\Omega$, yielding the following set of equations:
@f{eqnarray*}
  (\mathrm v,
   -\Delta \textbf{u}} + \nabla p)_{\Omega}
  -
  (q,\textrm{div}\; \textbf{u})_{\Omega}
  =
  (\textbf{v}, 0)_\Omega,
@f}
which has to hold for all test functions $\phi = \begin{pmatrix}\textbf{v}
\\ q\end{pmatrix}$.


By integrating by parts when possible, and exploiting the boundary
conditions on $\partial\Omega$, we obtain the following variational problem:
@f{eqnarray*}{
(\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} + (\nabla \cdot \textbf{v}, p)_{\Omega}
 + (q, \nabla \cdot \textbf{u})_{\Omega}&=& 0
@f}

where $(\cdot, \cdot)_{\Omega}$ represents the $L^2$ scalar product.

This variational formulation does not take into account the embedded domain. Contrarily
to step-60, we do not enforce strongly the constraints of $\textbf{u}$ on $\Gamma$,
but enforce them weakly through Nitsche's method. This is achieved by using the
following modified formulation :

@f{eqnarray*}{
(\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} + (\nabla \cdot \textbf{v}, p)_{\Omega}
 + (q, \nabla \cdot \textbf{u})_{\Omega} - (\nabla\textbf{v}\cdot \textbf{n},\textbf{u})_{\Gamma}
 + \beta (\textbf{v}},\textbf{u})_{\Gamma} &=&  -(\nabla\textbf{v}\cdot \textbf{n},\textbf{g})_{\Gamma}
 + \beta (\textbf{v},\textbf{g})_{\Gamma}
@f}

It can be shown (see  Freund, 1995) that there exist a positive constant
$C_1$ so that if $\beta > C_1$, the weak imposition of the boundary will
be consistent and stable. We note that the additional terms on the left-hand
and right-hand side are equal since $\textbf{u}=\textbf{g}\text{ in } \Gamma$.
It follows that :

@f{eqnarray*}{
(\nabla\textbf{v}\cdot \textbf{n},\textbf{u})_{\Gamma}
+ \beta (\textbf{v},\textbf{u})_{\Gamma} &=& -(\nabla\textbf{v}\cdot \textbf{n},\textbf{g})_{\Gamma}
+ \beta (\textbf{v},\textbf{g})_{\Gamma}
@f}

We note that an alternative formulation can be used :

@f{eqnarray*}{
(\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} + (\nabla \cdot \textbf{v}, p)_{\Omega}
 + (q, \nabla \cdot \textbf{u})_{\Omega} + (\nabla \textbf{v}\cdot \textbf{n},\textbf{u})_{\Gamma}
 + \beta (\textbf{v},\textbf{u})_{\Gamma} &=&  (\nabla \textbf{v}\cdot \textbf{n},\textbf{g})_{\Gamma}
 + \beta (\textbf{v},\textbf{g})_{\Gamma}
@f}

in which case the stability and consistency condition becomes $\beta > 0$.

In step-60, the imposition of the constraint in the strong form
required the addition of new variables in the form of the Lagrange multipliers.
This is not the case for this tutorial program. The imposition of the
boundary condition using Nitsche's method only modifies the system matrix
and the right-hand side without adding additional unknowns. However, the velocity
vector $\textbf{u}$ on the embedded domain will not match exactly the prescribed
velocity $\textbf{g}$. Furthermore, as in
step-60, we still need to integrate over the non-matching embedded grid in order
to construct the boundary term necessary to impose the boundary condition
over $\Gamma$.

<h3>Representation of $\Omega$ and $\Gamma$</h3>

In this tutorial, both the embedded grid $\Gamma$ and the embedding
grid are described using a parallel::distributed::Triangulation. These two
triangulations can be built from deal.II GridGenerators or by reading a
mesh file produced with another application (e.g. GMSH). This is slightly
more general than what has previously done step-60.

The main challenge in the application of the Nitsche method lies in the
integrals that are computed on $\Gamma$. As usual in finite elements we split this
integral into contributions from all cells of the triangulation used to
discretize $\Gamma$, we transform the integral on $K$ to an integral on the
reference element $\hat K$, where $F_{K}$ is the mapping from $\hat K$ to $K$,
and compute the integral on $\hat K$ using a quadrature formula. For example:

---- Here now ----


\f[
\beta (\textbf{v},\textbf{u})_{\Gamma} = (v_j, q_\alpha)_\Gamma  = \sum_{K\in \Gamma} \int_{\hat K}
\hat{\textbf{u}}(\hat x) (\textbf{v} \circ F_{K}) (\hat x) J_K (\hat x) \mathrm{d} \hat x =
\sum_{K\in \Gamma} \sum_{i=1}^{n_q}  \big(\hat \textbf{u}(\hat x_i)  (\textbf{v} \circ F_{K}) (\hat x_i) J_K (\hat x_i) w_i \big)
\f]

Computing this sum is non-trivial because we have to evaluate $(v_j \circ F_{K})
(\hat x_i)$. In general, if $\Gamma$ and $\Omega$ are not aligned, the point
$F_{K}(\hat x_i)$ is completely arbitrary with respect to $\Omega$, and unless
we figure out a way to interpolate all basis functions of $V_h(\Omega)$ on an
arbitrary point on $\Omega$, we cannot compute the integral needed for an entry
of the matrix $C$.




The Lagrange multiplier $\lambda$ and the user supplied function $g$ are
defined through another finite dimensional space `embedded_dh`, and through
another FiniteElement `embedded_fe`, using the same reference domain. In
order to take into account the deformation of the domain, either a MappingFEField
or a MappingQEulerian object are initialized with the `embedded_configuration`
vector.

In the embedding space, a standard finite dimensional space `space_dh` is
constructed on the embedding grid `space_grid`, using the
FiniteElement `space_fe`, following almost verbatim the approach taken in step-6.

We represent the discretizations of the spaces $V$ and $Q$ with
\f[
V_h(\Omega) = \text{span} \{v_i\}_{i=1}^n
\f]
and
\f[
Q_h(\Gamma) = \text{span} \{q_i\}_{i=1}^m
\f]
respectively, where $n$ is the dimension of `space_dh`, and $m$
the dimension of `embedded_dh`.

In particular, the integral that appears in the computation of a single entry of
$C$, is computed on $\Gamma$. As usual in finite elements we split this
integral into contributions from all cells of the triangulation used to
discretize $\Gamma$, we transform the integral on $K$ to an integral on the
reference element $\hat K$, where $F_{K}$ is the mapping from $\hat K$ to $K$,
and compute the integral on $\hat K$ using a quadrature formula:

\f[
C_{\alpha j} \dealcoloneq (v_j, q_\alpha)_\Gamma  = \sum_{K\in \Gamma} \int_{\hat K}
\hat q_\alpha(\hat x) (v_j \circ F_{K}) (\hat x) J_K (\hat x) \mathrm{d} \hat x =
\sum_{K\in \Gamma} \sum_{i=1}^{n_q}  \big(\hat q_\alpha(\hat x_i)  (v_j \circ F_{K}) (\hat x_i) J_K (\hat x_i) w_i \big)
\f]

Computing this sum is non-trivial because we have to evaluate $(v_j \circ F_{K})
(\hat x_i)$. In general, if $\Gamma$ and $\Omega$ are not aligned, the point
$F_{K}(\hat x_i)$ is completely arbitrary with respect to $\Omega$, and unless
we figure out a way to interpolate all basis functions of $V_h(\Omega)$ on an
arbitrary point on $\Omega$, we cannot compute the integral needed for an entry
of the matrix $C$.

To evaluate $(v_j \circ F_{K}) (\hat x_i)$ the following steps needs to be
taken (as shown in the picture below):

- For a given cell $K$ in $\Gamma$ compute the real point $y_i \dealcoloneq F_{K} (\hat
x_i)$, where $x_i$ is one of the quadrature points used for the integral on $K
\subseteq \Gamma$.

- Find the cell of $\Omega$ in which $y_i$ lies. We shall call this element $T$.

- To evaluate the basis function use the inverse of the mapping $G_T$ that
transforms the reference element $\hat T$ into the element $T$: $v_j(y_i) = \hat
v_j \circ G^{-1}_{T} (y_i)$.

<p align="center"> <img
  src="https://www.dealii.org/images/steps/developer/step-60.C_interpolation.png"
  alt=""> </p>

The three steps above can be computed by calling, in turn,

- GridTools::find_active_cell_around_point(), followed by

- Mapping::transform_real_to_unit_cell(). We then

- construct a custom Quadrature formula, containing the point in the reference
 cell and then

- construct an FEValues object, with the given quadrature formula, and
 initialized with the cell obtained in the first step.

This is what the deal.II function VectorTools::point_value() does when
evaluating a finite element field (not just a single shape function) at an
arbitrary point; but this would be inefficient in this case.

A better solution is to use a convenient wrapper to perform the first three
steps on a collection of points: GridTools::compute_point_locations(). If one is
actually interested in computing the full coupling matrix, then it is possible
to call the method NonMatching::create_coupling_mass_matrix(), that performs the
above steps in an efficient way, reusing all possible data structures, and
gathering expensive steps together. This is the function we'll be using later in
this tutorial.

We solve the final saddle point problem by an iterative solver, applied to the
Schur complement $S$ (whose construction is described, for example, in step-20),
and we construct $S$ using LinearOperator classes.


<h3>The testcase</h3>

The problem we solve here is a demonstration of the time-reversibility of Stokes
flow. This is often illustrated in science vulgarization experiments with a
Taylor-Couette flow and dye droplets that revert back to their original shape
after the fluid has been displaced in a periodic manner.

In the present problem, a very viscous fluid is agitated by the rotation of an impeller,
which, in 2D, is modeled by a rectangular grid. The impeller rotates for a
given number of revolutions and than, the flow is reversed such that the same number
of revolutions is carried out in the opposite direction. We recall that since the Stokes
equations are self-adjoint, creeping flows are reversible. Consequently,
if the impeller motion is reversed in the opposite direction, the fluid should
return to its original position. In the present case, this is illustrated by
inserting a circle of passive tracer particles that are advected by the fluid
and which return to their original position, thus demonstrating the time-reversibility
of the flow.


In the default scenario, $\Gamma$ has co-dimension zero, and this tutorial
program imposes motion of $\Gamma$ through Nitsche method. As it turns out,
very similar approaches are used in other fictitious boundary method. Consequently,
this step could be easily extended to account for a deformable embedded grid
by using a Lagrange multiplier approach and by solving the complete fluid-structure interaction problem.



<h3>References</h3>

- Glowinski, R., T.-W. Pan, T.I. Hesla, and D.D. Joseph. 1999. “A Distributed
  Lagrange Multiplier/fictitious Domain Method for Particulate Flows.”
  International Journal of Multiphase Flow 25 (5). Pergamon: 755–94.

- Boffi, D., L. Gastaldi, L. Heltai, and C.S. Peskin. 2008. “On the
  Hyper-Elastic Formulation of the Immersed Boundary Method.” Computer Methods
  in Applied Mechanics and Engineering 197 (25–28).

- Heltai, L., and F. Costanzo. 2012. “Variational Implementation of Immersed
  Finite Element Methods.” Computer Methods in Applied Mechanics and Engineering
  229–232.

- Freund, J., Stenberg, R. (1995). On weakly imposed boundary conditions for
  second order problems. Proceedings of the Ninth International Conference on
  Finite Elements in Fluids. 327-336.
