<br>

<i>This program was contributed by Fabian Castelli and Timo Heister.</i>

<a name="Intro"></a>
<h1>Introduction</h1>

The aim of this tutorial program is to demonstarte how to solve a nonlinear
problem using Newton's method within the matrix-free framework. This tutorial
combines several techniques already introduced in step-15, step 16, step-37,
step-48 and others.


<h3>Problem formulation</h3>
On the unit circle $\Omega = \bigl\{ x \in \mathbb{R}^2 : \|x\| \leq 1 \bigr\}$
we consider the following nonlinear elliptic boundary value problem subject to a
homogeneous Dirichlet boundary condition: Find a function
$u\colon\Omega\to\mathbb{R}$ such that holds:
@f{alignat*}{2}{
 - \Delta u &= \exp(u) & \qquad & \text{in } \Omega,\\
          u &= 0       & \qquad & \text{on } \partial\Omega.
@f}
This problem is also called the <i>Gelfand problem</i> and is a typical example
for problems from combustion theory, see for example in the book
<a href="https://link.springer.com/book/10.1007/978-1-4612-4546-9">
Mathematical Problems from Combustion Theory
by Jerrold Bebernes and David Eberly</a>


<h3>Discretization with finite elements</h3>
Even it is a nonlinear problem, we first derive the weak formulation for this
problem by multiplying with a smooth test function $v\colon\Omega\to\mathbb{R}$
respecting the boundary condition and integrate over the domain $\Omega$.
Integration by parts and putting the term on the right hand side to the left
yields the weak formulation: Find a function $u\colon\Omega \to\mathbb{R}$
such that for all test functions $v$ holds:
@f{align*}{
 \int_\Omega \nabla v \cdot \nabla u \,\mathrm{d}x
 -
 \int_\Omega v \exp(u) \,\mathrm{d}x.
@f}

Choosing the Lagrangian finite element space $V_h$ we can define a basis
$\{\varphi_i\}_{i=1,\dots,N}$ and it sufficies to test only with those basis
functions. So the discrete problem reads as follows: Find $u_h\in V_h$ such that
for all $i=1,\dots,N$ holds:
@f{align*}{
 F(u_h)
 \dealcoloneq
 \int_\Omega \nabla \varphi_i \cdot \nabla u_h \,\mathrm{d}x
 -
 \int_\Omega \varphi_i \exp(u_h) \,\mathrm{d}x = 0.
@f}
We directly defined the nonlinear function $F\colon\mathbb{R}^N\to\mathbb{R}^N$
representing the discrete nonlinear problem.

To solve this nonlinear problem we apply the Newton's method. So given an
initial guess $u_h^0\inV_h$ we determine a sequence of Newton steps
$\bigl( u_h^n \bigr)_n$ by successively apply the folowing scheme:
@f{alignat*}{2}{
 &\text{Solve for } s_h^n\in V_h: \qquad & F'(u_h^n)[s_h^n] &= -F(u_h^n),\\
 &\text{Update: } & u_h^{n+1} &= u_h^n + s_h^n.
@f}
In the discrete version the Jacobian
$F'(u_h^n)[\,\cdot\,]\colon\mathbb{R}^N\to\mathbb{R}^N$ represents just the
system matrix $A$ and the negative resiudal $-F(u_h^n)$ the right hand side $b$
of a linear system $Ax = b$. The solution vector $x$ is in that case the Newton
update of the $n$-th Newton step.

Unitl now we did not make use of the finite element ansatz at all, which means
that we can represent any function of $V_h$ as linear combination of basis
functions. More mathematically this means, that every element of $V_h$ can be
identified with a vector $U\in\mathbb{R}^N$ via the representation:
$u_h = \sum_{i=1}^N U_i \varphi_i$. So using this we can give an expression for
the discrete Jacobian and the residual:
@f{align*}{
 \bigl( F'(u_h^n) \bigr)_{i,j}
 =
 \int_\Omega \nabla\varphi_i \cdot \nabla \varphi_j \,\mathrm{d} x
 -
 \int_\Omega \varphi_i \, \exp( u_h ) \varphi_j \,\mathrm{d} x,\\
 \bigl( F(u_h^n) \bigr)_{i}
 &=
 \int_\Omega \nabla\varphi_i \cdot \nabla u_h^n \,\mathrm{d} x
 -
 \int_\Omega \varphi_i \, \exp( u_h^n ) \,\mathrm{d} x.
@f}
Compared to step-15 we could also have formed the Frech{\'e}t derivative of the
nonlinear function corresponding to the strong formulation of the problem and
discretized it afterwards. However, in the end we would have get the same set of
discrete equations.


<h3>Numerical linear algebra</h3>
Note, how the system matrix, actually the Jacobian, depends on the previous
Newton step $A = F'(u^n)$. Hence before we can use the system matrix we have to
tell it, what was the last Newton step. In an implemenation with a classical
assemble_system function we would gather this information from the last Newton
step during assembly by the use of the member functions get_function_values and
get_function_gradients of the FEValuesBase class. The assemble_system function
would then looks like:

@code
template<int dim>
void
BratuProblem<dim>::assemble_system()
{
  system_matrix = 0;
  system_rhs    = 0;
  
  const QGauss<dim> quadrature_fomrula(fe.degree+1);
  FEValues<dim> fe_values(fe, quadrature_formula,
                          update_values | update_gradients | update_JxW_values);
  
  const unsigned int n_q_points    = fe_values.n_quadrature_points;
  const unsigned int dofs_per_cell = fe_values.dofs_per_cell;
  
  FullMatrix<double>                   cell_matrix(dofs_per_cell);
  Vector<double>                       cell_rhs(dofs_per_cell);
  std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);
  
  std::vector<Tensor<1,dim> > newton_step_gradients(n_q_points);
  std::vector<double>         newton_step_values(n_q_points);
  
  
  for(const auto &cell : dof_handler.active_cell_iterators())
  {
	cell_matrix = 0.0;
	cell_rhs    = 0.0;
	
	fe_values.reinit(cell);
	
	fe_values.get_function_values(solution, newton_step_values);
	fe_values.get_function_gradients(solution, newton_step_gradients);
	
	for(unsigned int q=0; q<n_q_points; ++q)
	{
	  const double nonlinearity = std::exp(newton_step_values[q]);
	  const double dx           = fe_values.JxW(q);
	  
	  for(unsigned int i=0; i<dofs_per_cell; ++i)
	  {
		const double        phi_i      = fe_values.shape_value(i,q);
		const Tensor<1,dim> grad_phi_i = fe_values.shape_grad(i,q);
		
		for(unsigned int j=0; j<dofs_per_cell; ++j)
		{
		  const double        phi_j      = fe_values.shape_value(j,q);
		  const Tensor<1,dim> grad_phi_j = fe_values.shape_grad(j,q);
		  
		  cell_matrix(i,j) += ( grad_phi_i*grad_phi_j - phi_i*nonlinearity*phi_j ) * dx;
		}
		
		cell_rhs(i) += ( -grad_phi_i*newton_step_gradients[q] + phi_i*newton_step_values[q] ) * dx;
		
	  }
	}
	
	cell->get_dof_indices(local_dof_indices);
	
	constraints.distribute_local_to_global(cell_matrix, cell_rhs,
	                                       local_dof_indices,
	                                       system_matrix, system_rhs);
	
  }
  
}
@endcode

However, since we want to solve this problem without storing a matrix, we need
to tell the MatrixFreeOperator this information before we use it. Therefore in
the derived class JacobianMatrixFreeOperator we will implemenet a function
called evaluate_nonlinearity, which will process the information of the last
Newton step prior to usage of the matrix-vector implementation. Furthermore we
want to use a geometric multigrid preconditioner for the linear solver, so in
order to apply the multilevel operators we need to pass the last Newton step
also to these operators. This is kind of a tricky task, since the vector
containing the last Newton step has to be interpolated to all levels of the
triangulation. In the code this task will be done by the fucntion
interpolate_to_mg, which is a member of the MGTransferMatrixFree class:

@code
void
GelfandProblem<dim>::compute_update()
{
  solution.update_ghost_values();
  
  system_matrix.evaluate_nonlinearity(solution);
  
  MGTransferMatrixFree<dim,float> mg_transfer(mg_constrained_dofs);
  
  mg_transfer.interpolate_to_mg(dof_handler, mg_solution, solution);
  
  // Set up options for the multilevel preconditioner
  for(unsigend int level=0; level<triangulation.n_levels()-1; ++level)
  {
	mg_matrices[level].evaluate_nonlinearity(mg_solution[level]);
  }
  
  // Define the actual preconitioner
  ...
  
  // Solve the linear system
  ...
}
@endcode

The function evaluating the nonlinearity works basically like the function
evaluate_coefficient from step-37 evaluating a coefficient function. The idea is
to use a FEEvaluation object to evaluate the Newton step and store the
expression in a table for all cells and all quadrature points:

@code
void
JacobianOperator<dim,fe_degree,number>::evaluate_nonlinearity(const LinearAlgebra::distributed::Vector<number> &src)
{
  const unsigned int n_cells = this->data->n_macro_cells();
  FEEvaluation<dim,fe_degree,fe_degree+1,1,number> phi(*this->data);
	
  nl_values.reinit(n_cells, phi.n_q_points);
  for(unsigned int cell=0; cell<n_cells; ++cell)
  {
	phi.reinit(cell);
	phi.gather_evaluate(src, true, false);
	  
	for(unsigned int q=0; q<phi.n_q_points; ++q)
	  nl_values(cell, q) = std::exp(phi.get_value(q));
  }
}
@endcod


<h3>Triangulation</h3>
As said in step-37 the matrix-free method works more efficient if we choose a
higher order finite element space. Since we want to solve the problem on the
unit circle, it would be good to have an approprioate boundary approximation to
overcome convergence issues. For this reason we use the MappingC1 class to
recover the smooth boundary. In addition, to get a good triangulation in total
we make use of the TransfiniteInterpolationManifold.
